CYASM Version 2.04 
(C) 1998,1999,2000,2001,2002,2003, 2004 Cypress Semiconductor Corp.

                ;******************************************************
                ;
                ;File: enchid.asm
                ;adapted from Cypress Semiconductor's logo.asm by Jan Axelson
                ;Date: 07/1/2004
                ;Chip: Cypress Semiconductor CY7C637xx Encore series USB Microcontroller
                ;Assembler: cyasm.exe
                
                ;Purpose: demonstrates USB communications with a HID-class device
                ;Description:
                ;Handles standard USB and HID-class requests.
                
                ;Supports Input reports using control and interrupt transfers,
                ;Output reports using control transfers,
                ;and Feature IN and OUT reports.
                
                ;The Input report returns the data received in the last Output report.
                ;The IN Feature report returns the data received in the last OUT Feature report.
                
                ;I used Cypress Semiconductor's logo.asm example code as a base 
                ;in creating this program. Most of the code is Cypress'.
                
                ;Companion host software is at www.Lvr.com/hidpage.htm
                
                ;For more information, visit Lakeview Research at http://www.lvr.com .
                ;Send comments, bug reports, etc. to jan@lvr.com .
                
                ;7/1/2004
                ;Added support for Feature reports and Input reports using control transfers.
                
                ;2/19/2001
                ;Changed endpoint 1 ISR so it doesn't toggle the data toggle on NAK.
                
                ;       Target: Cypress CY7C63743
                ;
                ;       Overview:  There is only one task handled by this
                ;                               firmware, and that is USB.
                ;
                ;       USB
                ;               At bus reset the USB interface is re-initialized,
                ;               and the firmware soft reboots.  We are then able to
                ;               handle the standard chapter nine requests on 
                ;               endpoint zero (the control endpoint).  After this
                ;               device enumerates as a HID mouse on the USB, the
                ;               requests come to endpoint one (the data endpoint).
                ;               Endpoint one is used to send Input reports.
                ;               Endpoint zero is used to receive Output reports
                ;               in Set_Report requests.
                ;
                ;       Pin Connections
                ;
                ;                        -------------------
                ;                       | P0[0]         P0[4]   |
                ;                       | P0[1]         P0[5]   |
                ;                       | P0[2]         P0[6]   |
                ;                       | P0[3]         P0[7]   |
                ;                       | P1[0]         P1[1]   |       
                ;                       | P1[2]         P1[3]   |
                ;                       | P1[4]         P1[5]   |
                ;                       | P1[6]         P1[7]   |
                ;       GND             | VSS           D+/SCLK |       USB D+ / PS2 SCLK
                ;       GND             | VPP           D-/SDATA|       USB D- / PS2 SDATA
                ;       PULLUP  | VREG          VCC             |       +5
                ;                       | XTALIN        XTALOUT |
                ;                        -------------------
                ;
                ; Revisions:
                ;                       9-25-2000                       Creation
                ;
                ;To do (things to be added):
                ;Add ability to send and receive Feature reports.
                ;Add ability to receive Output reports > 8 bytes.
                ;Add ability to receive interrupt Out reports.
                ;Move watchdog reset out of 1-ms timer routine.
                ;
                ;**********************************************************
                ;
                ;       Copyright 2000 Cypress Semiconductor and Lakeview Research
                ;       Portions of this code are provided by Cypress and by
                ;       Lakeview Research as a reference.  Cypress and Lakeview
                ;       make no claims or warranties to this firmware's 
                ;       suitability for any application.
                ;
                ;********************************************************** 
                
                ;**************** assembler directives ***************** 
                
0000                    CPU     63743
                
0000                    XPAGEON
                
                
                ; processor registers
0000=           port0:                          equ     00h
0001=           port1:                          equ     01h
0002=           port2:                          equ     02h
                
0004=           port0_int:                      equ     04h
0005=           port1_int:                      equ     05h
0006=           port0_int_polarity:     equ     06h
0007=           port1_int_polarity:     equ     07h
                
000A=           port0_mode0:            equ     0Ah
000B=           port0_mode1:            equ     0Bh
000C=           port1_mode0:            equ     0Ch
000D=           port1_mode1:            equ     0Dh
                
0010=           usb_address:            equ     10h
0011=           ep0_count:                      equ     11h
0012=           ep0_mode:                       equ     12h
0013=           ep1_count:                      equ     13h
0014=           ep1_mode:                       equ     14h
0015=           ep2_count:                      equ     15h
0016=           ep2_mode:                       equ     16h
001F=           usb_status:                     equ     1Fh
                
0020=           global_int:                     equ     20h
0021=           endpoint_int:           equ     21h
0024=           timer_lsb:                      equ     24h
0025=           timer_msb:                      equ     25h
0026=           watchdog:                       equ     26h
                
0040=           capturea_rising:        equ     40h
0041=           capturea_falling:       equ     41h
0042=           captureb_rising:        equ     42h
0043=           captureb_falling:       equ     43h
0044=           capture_config:         equ     44h
0045=           capture_status:         equ     45h
                
0060=           spi_data:                       equ     60h
0061=           spi_control:            equ     61h
                
00F8=           clock_config:           equ     F8h
00FF=           control:                        equ     FFh
                
                ; Port 2 Data Register 0x02 bit assignments
0020=           SCLK:                           equ     20h
0020=           DPLUS:                          equ     20h
0010=           SDATA:                          equ     10h
0010=           DMINUS:                         equ     10h
0002=           XTALIN:                         equ     02h
0001=           VREG:                           equ     01h
                
                ; USB Port status and control register 0x1F bit assignments
0080=           PS2_PULLUP:                     equ     80h
0040=           VREG_ENABLE:            equ     40h
0020=           USB_PS2_MODE:           equ     20h
0008=           BUS_ACTIVITY:           equ     08h
0004=           CONTROL2:                       equ     04h
0002=           CONTROL1:                       equ     02h
0001=           CONTROL0:                       equ     01h
                
0000=           NOT_FORCING:            equ     00h
0001=           FORCE_K:                        equ     01h
0002=           FORCE_J:                        equ     02h
0003=           FORCE_SE0:                      equ     03h
0040=           FORCEBOTH_LOW:          equ     40h
0005=           FORCESDATA_LOW:         equ     05h
0006=           FORCESCLK_LOW:          equ     06h
0007=           FORCE_HIZ:                      equ     07h
                
                ; USB Device Address Registers 0x10 bit assignments
0080=           ADDRESS_ENABLE:         equ     80h
007F=           ADDRESS_MASK:           equ     7Fh
                
                ; USB Device EP0 Mode Register 0x12
0080=           EP0_SETUP:                      equ     80h
0040=           EP0_IN:                         equ     40h
0020=           EP0_OUT:                        equ     20h
0010=           EP0_ACK:                        equ     10h
000F=           MODE_MASK:                      equ     0Fh
                
                ; USB Device Endpoint Mode Registers 0x14, 0x16
0080=           EP_STALL:                       equ     80h
0010=           EP_ACK:                         equ     10h
                
                ; USB Device Counter Registers 0x11, 0x13, 0x15
0080=           DATA_TOGGLE:            equ     80h
0040=           DATA_VALID:                     equ     40h
000F=           BYTE_COUNT:                     equ     0Fh
                
                ;Capture Timers Configuration Register 0x44
0080=           FIRST_EDGE_HOLD:        equ     80h
0070=           PRESCALE:                       equ     70h
0040=           PRESCALE2:                      equ     40h
0020=           PRESCALE1:                      equ     20h
0010=           PRESCALE0:                      equ     10h
0008=           CAPTUREB_FALL_INT:      equ     08h
0004=           CAPTUREB_RISE_INT:      equ     04h
0002=           CAPTUREA_FALL_INT:      equ     02h
0001=           CAPTUREA_RISE_INT:      equ     01h
                
                ;Capture Timers Status Register 0x45
0008=           CAPTUREB_FALL_EVENT:    equ     08h
0004=           CAPTUREB_RISE_EVENT:    equ     04h
0002=           CAPTUREA_FALL_EVENT:    equ     02h
0001=           CAPTUREA_RISE_EVENT:    equ     01h
                
                ;Processor Status and Control Register 0xFF
0080=           IRQ_PENDING:            equ     80h
0040=           WDR:                            equ     40h
0020=           USB_RESET:                      equ     20h
0010=           POR_RESET:                      equ     10h
0008=           SUSPEND:                        equ     08h
0004=           INT_ENABLE_SENSE:       equ     04h
0001=           RUN:                            equ     01h
                
                ; global interrupt enable register 0x20 bit assignments
0080=           WAKEUP_INT:                     equ     80h
0040=           GPIO_INT:                       equ     40h
0020=           CAPTUREB_INT:           equ     20h
0010=           CAPTUREA_INT:           equ     10h
0008=           SPI_INT:                        equ     08h
0004=           1MS_INT:                        equ     04h
0002=           128US_INT:                      equ     02h
0001=           USB_RESET_INT:          equ     01h
                
                ; USB Endpoint Interrupt Enable Register 0x21 bit assignments
0004=           EP2_INT:                        equ     04h
0002=           EP1_INT:                        equ     02h
0001=           EP0_INT:                        equ     01h
                
                ; SPI Control Register 0x61 bit assignments
0080=           TCMP:                           equ     80h
0040=           TBF:                            equ     40h
0020=           MODE1:                          equ     20h
0010=           MODE0:                          equ     10h
0008=           CPOL:                           equ 08h
0004=           CPHA:                           equ 04h
0002=           SCK_SELECT1:            equ 02h
0001=           SCK_SELECT0:            equ     01h     
                
                ; Clock Configuration Register 0xF8 bit assignments
0080=           EXT_DELAY:                      equ     80h
0040=           WAKEUP_ADJUST2:         equ     40h
0020=           WAKEUP_ADJUST1:         equ     20h
0010=           WAKEUP_ADJUST0:         equ     10h
0008=           LVR_ENABLE:                     equ     08h
0002=           INTERNAL_CLK:           equ     02h
0001=           EXTERNAL_CLK:           equ     01h
                
                ; USB register mode encoding
0000=           DISABLE:                        equ     00h
0001=           NAK_IN_OUT:                     equ     01h
0002=           STATUS_OUT_ONLY:        equ     02h
0003=           STALL_IN_OUT:           equ     03h
0004=           IGNORE_IN_OUT:          equ     04h
0005=           ISOCHRONOUS_OUT:        equ     05h
0006=           STATUS_IN_ONLY:         equ     06h
0007=           ISOCHRONOUS_IN:         equ     07h
0008=           NAK_OUT:                        equ     08h
0009=           ACK_OUT:                        equ     09h
000A=           NAK_OUT_STATUS_IN:      equ     0Ah
000B=           ACK_OUT_NAK_IN:         equ     0Bh
000C=           NAK_IN:                         equ     0Ch
000D=           ACK_IN:                         equ     0Dh
000E=           NAK_IN_STATUS_OUT:      equ     0Eh
000F=           ACK_IN_STATUS_OUT:      equ     0Fh
                
                
00FF=           SET:                            equ     FFh
0000=           CLEAR:                          equ     00h
                
                ;**********************************************************
                ; USB Descriptor and Request constants
                ;       source p172,,175 USB specification
                ;**********************************************************
                
                
                ;       Characterists of bmRequest Value
                ;
                ; D7    Data xfer direction
                ;       0 = Host to device
                ;       1 = Device to host
                ;
                ; D6..5 Type
                ;       0 = Standard
                ;       1 = Class
                ;       2 = Vendor
                ;       3 = Reserved
                ;
                ; D4..0 Recipient
                ;       0 = Device
                ;       1 = Interface
                ;       2 = Endpoint
                ;       3 = Other
                ;       4..31 = Reserved
                
                
                ;***** bmRequestType
0000=           HOSTTODEVICE:                   equ     00h
0080=           DEVICETOHOST:                   equ     80h
                
0000=           STANDARD_TYPE:                  equ     00h
0020=           CLASS_TYPE:                             equ     20h
0040=           VENDOR_TYPE:                    equ     40h
0060=           RESERVED_TYPE:                  equ     60h
                
0000=           DEVICE_RECIPIENT:               equ     00h
0001=           INTERFACE_RECIPIENT:    equ     01h
0002=           ENDPOINT_RECIPIENT:             equ     02h
0003=           OTHER_RECIPIENT:                equ     03h
                
                ;***** bRequest
0000=           GET_STATUS:                             equ     00h
0001=           CLEAR_FEATURE:                  equ     01h
0003=           SET_FEATURE:                    equ     03h
0005=           SET_ADDRESS:                    equ     05h
0006=           GET_DESCRIPTOR:                 equ     06h
0007=           SET_DESCRIPTOR:                 equ     07h
0008=           GET_CONFIGURATION:              equ     08h
0009=           SET_CONFIGURATION:              equ     09h
000A=           GET_INTERFACE:                  equ     0Ah
000B=           SET_INTERFACE:                  equ     0Bh
000C=           SYNCH_FRAME:                    equ     0Ch
                
                ;***** Descriptor Types
0001=           DEVICE:                                 equ     01h
0002=           CONFIGURATION:                  equ     02h
0003=           STRING:                                 equ     03h
0004=           INTERFACE:                              equ     04h
0005=           ENDPOINT:                               equ     05h
                
                ;***** Feature Selectors
0001=           DEVICE_REMOTE_WAKEUP:   equ     01h
0000=           ENDPOINT_STALL:                 equ     00h
                
                ;***** HID Class Request Types
0001=           GET_REPORT:                             equ     01h
0002=           GET_IDLE:                               equ     02h
0003=           GET_PROTOCOL:                   equ     03h
0009=           SET_REPORT:                             equ     09h
000A=           SET_IDLE:                               equ     0Ah
000B=           SET_PROTOCOL:                   equ     0Bh
                
00F0=           ep1_dmabuff:                    equ     F0h
00F0=           ep1_dmabuff0:                   equ     ep1_dmabuff+0
00F1=           ep1_dmabuff1:                   equ     ep1_dmabuff+1
00F2=           ep1_dmabuff2:                   equ     ep1_dmabuff+2
00F3=           ep1_dmabuff3:                   equ     ep1_dmabuff+3
00F4=           ep1_dmabuff4:                   equ     ep1_dmabuff+4
00F5=           ep1_dmabuff5:                   equ     ep1_dmabuff+5
00F6=           ep1_dmabuff6:                   equ     ep1_dmabuff+6
00F7=           ep1_dmabuff7:                   equ     ep1_dmabuff+7
                
00F8=           ep0_dmabuff:                    equ     F8h
00F8=           ep0_dmabuff0:                   equ     ep0_dmabuff+0
00F9=           ep0_dmabuff1:                   equ     ep0_dmabuff+1
00FA=           ep0_dmabuff2:                   equ     ep0_dmabuff+2
00FB=           ep0_dmabuff3:                   equ     ep0_dmabuff+3
00FC=           ep0_dmabuff4:                   equ     ep0_dmabuff+4
00FD=           ep0_dmabuff5:                   equ     ep0_dmabuff+5
00FE=           ep0_dmabuff6:                   equ     ep0_dmabuff+6
00FF=           ep0_dmabuff7:                   equ     ep0_dmabuff+7
                
00F8=           bmRequestType:                  equ     ep0_dmabuff0
00F9=           bRequest:                               equ     ep0_dmabuff1
00FA=           wValuelo:                               equ     ep0_dmabuff2
00FB=           wValuehi:                               equ     ep0_dmabuff3
00FC=           wIndexlo:                               equ     ep0_dmabuff4
00FD=           wIndexhi:                               equ     ep0_dmabuff5
00FE=           wLengthlo:                              equ     ep0_dmabuff6
                
00FF=           wLengthhi:                              equ     ep0_dmabuff7
                
                
                ; DATA MEMORY VARIABLES
                ;
0020=           suspend_count:                  equ     20h             ; counter for suspend/resume
0021=           ep1_data_toggle:                equ     21h             ; data toggle for INs on endpoint one
0022=           ep0_data_toggle:                equ     22h             ; data toggle for INs on endpoint zero
                
                
                
                
0023=           data_start:                             equ     23h             ; address of request response data, as an offset
0024=           data_count:                             equ     24h             ; number of bytes to send back to the host
0025=           maximum_data_count:             equ     25h             ; request response size
0026=           ep0_in_machine:                 equ     26h             
0027=           ep0_in_flag:                    equ     27h
0028=           configuration:                  equ     28h
0029=           ep1_stall:                              equ     29h
002A=           idle:                                   equ     2Ah
002B=           protocol:                               equ     2Bh
002C=           temp:                                   equ     2Ch             ; temporary register
002D=           event_machine:                  equ     2Dh
002E=           pending_data:                   equ     2Eh
002F=           int_temp:                               equ     2Fh
0030=           idle_timer:                             equ     30h
0031=           idle_prescaler:                 equ     31h
0032=           logo_index:                             equ     32h
0033=           ep0_transtype:                  equ     33h
                
0034=           data_byte_0:                    equ     34h
0035=           data_byte_1:                    equ     35h
0036=           output_report_received:         equ     36h
0037=           output_or_feature:                      equ     37h
                
                
0038=           feature_report_byte_0:                  equ     38h
00F1=           feature_report_byte_1:                  equ     ep1_dmabuff+1
00F2=           feature_report_byte_2:                  equ     ep1_dmabuff+2
00F3=           feature_report_byte_3:                  equ     ep1_dmabuff+3
00F4=           feature_report_byte_4:                  equ     ep1_dmabuff+4
00F5=           feature_report_byte_5:                  equ     ep1_dmabuff+5
00F6=           feature_report_byte_6:                  equ     ep1_dmabuff+6
00F7=           feature_report_byte_7:                  equ     ep1_dmabuff+7
                
0040=           input_report_byte_0:                    equ     40h
00F1=           input_report_byte_1:                    equ     ep1_dmabuff+1
00F2=           input_report_byte_2:                    equ     ep1_dmabuff+2
00F3=           input_report_byte_3:                    equ     ep1_dmabuff+3
00F4=           input_report_byte_4:                    equ     ep1_dmabuff+4
00F5=           input_report_byte_5:                    equ     ep1_dmabuff+5
00F6=           input_report_byte_6:                    equ     ep1_dmabuff+6
00F7=           input_report_byte_7:                    equ     ep1_dmabuff+7
                
0048=           output_report_byte_0:                   equ     48h
00F1=           output_report_byte_1:                   equ     ep1_dmabuff+1
00F2=           output_report_byte_2:                   equ     ep1_dmabuff+2
00F3=           output_report_byte_3:                   equ     ep1_dmabuff+3
00F4=           output_report_byte_4:                   equ     ep1_dmabuff+4
00F5=           output_report_byte_5:                   equ     ep1_dmabuff+5
00F6=           output_report_byte_6:                   equ     ep1_dmabuff+6
00F7=           output_report_byte_7:                   equ     ep1_dmabuff+7
                
0050=           port0_data_temp                 :     equ 50h
0051=           port1_data_temp                 :     equ 51h
                
                
                ; STATE MACHINE CONSTANTS
                ;EP0 IN TRANSACTIONS
0000=           EP0_IN_IDLE:                    equ     00h
0002=           CONTROL_READ_DATA:              equ     02h
0004=           NO_DATA_STATUS:                 equ     04h
0006=           EP0_IN_STALL:                   equ     06h
                
                ; FLAG CONSTANTS
                ;EP0 NO-DATA CONTROL FLAGS
0000=           ADDRESS_CHANGE_PENDING: equ     00h
0002=           NO_CHANGE_PENDING:              equ     02h
                
                ; RESPONSE SIZES
0002=           DEVICE_STATUS_LENGTH:           equ     2
0001=           DEVICE_CONFIG_LENGTH:           equ     1
0002=           ENDPOINT_STALL_LENGTH:          equ 2
0002=           INTERFACE_STATUS_LENGTH:        equ 2
0001=           INTERFACE_ALTERNATE_LENGTH:     equ     1
0001=           INTERFACE_PROTOCOL_LENGTH:      equ     1
                
0000=           NO_EVENT_PENDING:                       equ     00h
0002=           EVENT_PENDING:                          equ     02h
                
                ;***** TRANSACTION TYPES
                
0000=           TRANS_NONE:                                             equ     00h
0002=           TRANS_CONTROL_READ:                             equ     02h
0004=           TRANS_CONTROL_WRITE:                    equ     04h
0006=           TRANS_NO_DATA_CONTROL:                  equ     06h
                
                ;Additional notes:
                ;ep0_mode is the Endpoint 0 mode register (12h).
                
                
                ;*************** interrupt vector table ****************
                
0000            ORG 00h                 
                
0000 80 1B [05] jmp     reset                           ; reset vector          
                
0002 80 B7 [05] jmp     bus_reset                       ; bus reset interrupt
                
0004 80 1A [05] jmp     error                           ; 128us interrupt
                
0006 80 C8 [05] jmp     1ms_timer                       ; 1.024ms interrupt
                
0008 80 FD [05] jmp     endpoint0                       ; endpoint 0 interrupt
                
000A 84 3E [05] jmp     endpoint1                       ; endpoint 1 interrupt
                
000C 80 1A [05] jmp     error                           ; endpoint 2 interrupt
                
000E 80 1A [05] jmp     error                           ; reserved
                
0010 80 1A [05] jmp     error                           ; Capture timer A interrupt Vector
                
0012 80 1A [05] jmp     error                           ; Capture timer B interrupt Vector
                
0014 80 1A [05] jmp     error                           ; GPIO interrupt vector
                
0016 80 1A [05] jmp     error                           ; Wake-up interrupt vector 
                
                
                ;************** program listing ************************
                
001A            ORG  1Ah
001A 00    [07] error: halt
                
                ;*******************************************************
                ;
                ;       Interrupt handler: reset
                ;       Purpose: The program jumps to this routine when
                ;                the microcontroller has a power on reset.
                ;
                ;*******************************************************
                
001B            reset:
                        ; set for use with external oscillator
001B 19 09 [04]         mov             A, (LVR_ENABLE | EXTERNAL_CLK)  
001D 2A F8 [05]         iowr    clock_config
                
                        ; setup data memory stack pointer
001F 19 68 [04]         mov             A, 68h
0021 30    [05]         swap    A, dsp          
                
                        ; clear variables
0022 19 00 [04]         mov             A, 00h          
0024 31 26 [05]         mov             [ep0_in_machine], A             ; clear ep0 state machine
0026 31 28 [05]         mov             [configuration], A
0028 31 29 [05]         mov             [ep1_stall], A
002A 31 2A [05]         mov             [idle], A
002C 31 20 [05]         mov             [suspend_count], A
002E 31 F0 [05]         mov             [ep1_dmabuff0], A
0030 31 F1 [05]         mov             [ep1_dmabuff1], A
0032 31 F2 [05]         mov             [ep1_dmabuff2], A
0034 31 2F [05]         mov             [int_temp], A
0036 31 30 [05]         mov             [idle_timer], A
0038 31 31 [05]         mov             [idle_prescaler], A
003A 31 2D [05]         mov             [event_machine], A
003C 31 32 [05]         mov             [logo_index], A
003E 31 33 [05]         mov             [ep0_transtype], A
                
0040 19 01 [04]         mov             A, 01h
0042 31 2B [05]         mov             [protocol], A
                
                        ;-------------------------------------------------------
                        ; Set Port0 : M1,M0 = 01 : output
                        ;-------------------------------------------------------
0044 19 FF [04]         mov     A, FFh
0046 2A 0A [05]         iowr    port0_mode0
0048 19 00 [04]         mov     A, 00h
004A 2A 0B [05]         iowr    port0_mode1
004C 2A 00 [05]         iowr    port0
                        ;-------------------------------------------------------
                        ; Set Port1 : D, M1,M0 = 110 : input
                        ;-------------------------------------------------------
004E 19 00 [04]         mov     A, 00h
0050 2A 0C [05]         iowr    port1_mode0             ; Port1 M0   = 0
0052 19 FF [04]         mov     A, FFh
0054 2A 0D [05]         iowr    port1_mode1             ; Port1 M1   = 1
0056 2A 01 [05]         iowr    port1                                   ; Port1 Data = 1
                
                
                
                
                        ; enable global interrupts
0058 19 05 [04]         mov             A, (1MS_INT | USB_RESET_INT)
005A 2A 20 [05]         iowr    global_int
                
                        ; enable endpoint  0 interrupt
005C 19 01 [04]         mov     A, EP0_INT                      
005E 2A 21 [05]         iowr    endpoint_int
                
                        ; enable USB address for endpoint 0
0060 19 80 [04]         mov             A, ADDRESS_ENABLE
0062 2A 10 [05]         iowr    usb_address
                
                        ; enable all interrupts
0064 72    [04]         ei
                
                        ; enable USB pullup resistor
0065 19 40 [04]         mov             A, VREG_ENABLE  
0067 2A 1F [05]         iowr    usb_status
                
0069            task_loop:
                
                
                ;-------------------------------------------------------
                        ; Set Port0 : M1,M0 = 01 : output
                        ;-------------------------------------------------------
0069 19 FF [04]         mov     A, FFh
006B 2A 0A [05]         iowr    port0_mode0
006D 19 00 [04]         mov     A, 00h
006F 2A 0B [05]         iowr    port0_mode1
                ;       iowr    port0
                
0071 1A 50 [05]                         mov             A, [port0_data_temp]
0073 2A 00 [05]                         iowr            port0
                
                        ;-------------------------------------------------------
                        ; Set Port1 : D, M1,M0 = 110 : input
                        ;-------------------------------------------------------
0075 19 00 [04]         mov     A, 00h
0077 2A 0C [05]         iowr    port1_mode0             ; Port1 M0   = 0
0079 19 FF [04]         mov     A, FFh
007B 2A 0D [05]         iowr    port1_mode1             ; Port1 M1   = 1
007D 2A 01 [05]         iowr    port1                                   ; Port1 Data = 1
                
                ;                       mov             A, [port1_data_temp]
                ;                       iowr            port1
                ;--------------------------------------------------------------------
007F 1A 2D [05]         mov             A, [event_machine]
                
0081 E9 00 [07]         jacc    event_machine_jumptable
0083                            no_event_pending:
                
0083 1A 36 [05]                 mov     A, [output_report_received]
0085 16 00 [05]                 cmp     A, 0
                
0087 A0 B1 [05]                 jz      no_input_report_to_send
                
                                        ; if not configured then skip data transfer
0089 1A 28 [05]                         mov             A, [configuration]
008B 16 01 [05]                         cmp             A, 01h
008D B0 B5 [05]                         jnz             no_event_task
                                        ; if stalled then skip data transfer
008F 1A 29 [05]                         mov             A, [ep1_stall]
0091 16 FF [05]                         cmp             A, FFh
0093 A0 B5 [05]                         jz              no_event_task
                                        
                                        ;copy the received output report data to endpoint 1's buffer
                                        ;to return to the host in an Input report.
                ;                       mov             A, [output_report_byte_0]
0095 29 01 [05]       iord  port1
0097 31 F0 [05]                         mov             [ep1_dmabuff0], A
                ;                       mov             A, [output_report_byte_0]
0099 29 01 [05]       iord  port1
009B 31 F0 [05]                         mov             [ep1_dmabuff0], A
                
009D 19 02 [04]                         mov             A, 02h          ; set endpoint 1 to send 2 bytes
009F 0E 21 [06]                         or              A, [ep1_data_toggle]
00A1 2A 13 [05]                         iowr    ep1_count
00A3 19 0D [04]                         mov             A, ACK_IN               ; set to ack on endpoint 1
00A5 2A 14 [05]                         iowr    ep1_mode        
                
                ;Set output_report_received to 0 to indicate the report has been handled.
00A7 19 00 [04]                         mov             A, 00h
00A9 31 36 [05]                         mov             [output_report_received], A
                
00AB            clear_pending_events:
00AB 19 02 [04]                         mov             A, EVENT_PENDING        ; clear pending events
00AD 31 2D [05]                         mov             [event_machine], A 
                
                
                
                
00AF 80 69 [05] jmp task_loop
00B1                            no_input_report_to_send:
00B1 19 01 [04]                         mov             A, NAK_IN_OUT           ; set to NAK on endpoint 1
00B3 2A 14 [05]                         iowr    ep1_mode        
                
00B5                            event_task_done:
                
                
                
00B5                    no_event_task:
00B5                    event_pending:
                
                
                
                
00B5 80 69 [05]         jmp task_loop
                
                
                ;*******************************************************
                ;
                ;       Interrupt handler: bus_reset
                ;       Purpose: The program jumps to this routine when
                ;                the microcontroller has a bus reset.
                ;
                ;*******************************************************
                
00B7            bus_reset:
00B7 19 03 [04]         mov             A, STALL_IN_OUT                 ; set to STALL INs&OUTs
00B9 2A 12 [05]         iowr    ep0_mode
                
00BB 19 80 [04]         mov             A, ADDRESS_ENABLE               ; enable USB address 0
00BD 2A 10 [05]         iowr    usb_address
00BF 19 00 [04]         mov             A, DISABLE                              ; disable endpoint1
00C1 2A 14 [05]         iowr    ep1_mode
                
00C3 19 00 [04]         mov             A, 00h                                  ; reset program stack pointer
00C5 60    [04]         mov             psp,a   
                
00C6 80 1B [05]         jmp             reset
                
                
                ;*******************************************************
                ;
                ;       Interrupt: 1ms_clear_control
                ;       Purpose: Every 1ms this interrupt handler clears
                ;               the watchdog timer.
                ;
                ;*******************************************************
                
00C8            1ms_timer:
00C8 2D    [05]         push A
                
                        ; clear watchdog timer
00C9 2A 26 [05]         iowr watchdog
                
                        ; check for no bus activity/usb suspend
00CB              1ms_suspend_timer:
00CB 29 1F [05]         iord    usb_status                              ; read bus activity bit
00CD 10 08 [04]         and             A, BUS_ACTIVITY                 ; mask off activity bit
                
00CF B0 F1 [05]         jnz             bus_activity
                                        
00D1 23 20 [07]         inc             [suspend_count]                 ; increment suspend counter
00D3 1A 20 [05]         mov             A, [suspend_count]
00D5 16 04 [05]         cmp             A, 04h                                  ; if no bus activity for 3-4ms,
00D7 A0 DB [05]         jz              usb_suspend                             ; then go into low power suspend
00D9 80 FB [05]         jmp             ms_timer_done
                
00DB                    usb_suspend:
                
                                ; enable wakeup timer
                
00DB 19 01 [04]                 mov             A, (USB_RESET_INT)
00DD 2A 20 [05]                 iowr    global_int
                
00DF 29 FF [05]         iord    control
00E1 0D 08 [04]         or              A, SUSPEND                      ; set suspend bit
00E3 72    [04]                 ei
00E4 2A FF [05]                 iowr    control
00E6 20    [04]                 nop
                
                                ; look for bus activity, if none go back into suspend
00E7 29 1F [05]                 iord    usb_status
00E9 10 08 [04]                 and             A, BUS_ACTIVITY
00EB A0 DB [05]                 jz              usb_suspend             
                
                                ; re-enable interrupts
00ED 19 05 [04]                 mov             A, (1MS_INT | USB_RESET_INT)
00EF 2A 20 [05]                 iowr    global_int
                
                
00F1                    bus_activity:
00F1 19 00 [04]                 mov             A, 00h                          ; reset suspend counter
00F3 31 20 [05]                 mov             [suspend_count], A
00F5 29 1F [05]                 iord    usb_status
00F7 10 F7 [04]                 and             A, ~BUS_ACTIVITY        ; clear bus activity bit
00F9 2A 1F [05]                 iowr    usb_status
                
                
00FB                    ms_timer_done:
00FB 2B    [04]                 pop A
00FC 73    [08]                 reti
                
                ;*******************************************************
                ;
                ;       Interrupt: endpoint0
                ;       Purpose: Usb control endpoint handler.  This interrupt
                ;                       handler formulates responses to SETUP and 
                ;                       CONTROL READ, and NO-DATA CONTROL transactions. 
                ;
                ;       Jump table entry formulation for bmRequestType and bRequest
                ;
                ;       1. Add high and low nibbles of bmRequestType.
                ;       2. Put result into high nibble of A.
                ;       3. Mask off bits [6:4].
                ;       4. Add bRequest to A.
                ;       5. Double value of A (jmp is two bytes).
                ;
                ;*******************************************************
                
00FD            endpoint0:
00FD 2E    [05]         push    X
00FE 2D    [05]         push    A
                
                ;Reading ep0_mode enables writing to the endpoint's buffer.
00FF 1F    [04]         XPAGE
0100 29 12 [05]         iord    ep0_mode
                ;If EP0_ACK isn't set, the transaction didn't complete with an Ack,
                ;so exit the ISR.
0102 10 10 [04]         and             A, EP0_ACK
0104 A1 11 [05]         jz              ep0_done
                
                ;Bit 5, 6, or 7 is set to indicate whether the transaction is
                ;Setup, In, or Out. Find out which it is and jump to a routine to handle it.
0106 29 12 [05]         iord    ep0_mode
0108 3B    [04]         asl             A
                
0109 C1 14 [05]         jc              ep0_setup_received
010B 3B    [04]         asl             A
010C C3 92 [05]         jc              ep0_in_received
010E 3B    [04]         asl             A
010F C3 E6 [05]         jc              ep0_out_received
                
0111              ep0_done:
0111 2B    [04]         pop             A
0112 2C    [04]         pop             X
0113 73    [08]         reti
                
0114                    ep0_setup_received:
                
0114 19 01 [04]                 mov             A, NAK_IN_OUT                           ; clear setup bit to enable
0116 2A 12 [05]                 iowr    ep0_mode                                        ; writes to EP0 DMA buffer
                
                
                
                
0118 1A F8 [05]                 mov             A, [bmRequestType]                      ; compact bmRequestType into 5 bit field
011A 10 E3 [04]                 and             A, E3h                                          ; clear bits 4-3-2, these unused for our purposes
011C 2D    [05]                 push    A                                                       ; store value
011D 3C    [04]                 asr             A                                                       ; move bits 7-6-5 into 4-3-2's place
011E 3C    [04]                 asr             A
011F 3C    [04]                 asr             A
0120 31 2F [05]                 mov             [int_temp], A                           ; store shifted value
0122 2B    [04]                 pop             A                                                       ; get original value
0123 0E 2F [06]                 or              A, [int_temp]                           ; or the two to get the 5-bit field
0125 10 1F [04]                 and             A, 1Fh                                          ; clear bits 7-6-5 (asr wraps bit7)
0127 3B    [04]                 asl             A                                                       ; shift to index jumptable
                
                ;Use bmRequestType to find out whether the request is host-to-device (h2d)
                ;or device-to-host (d2h), and whether the request is for the device, an ;interface, or an endpoint.
0128 E6 00 [07]                 jacc    bmRequestType_jumptable         ; jump to handle bmRequestType
                
                ;Use the request's value to decide where to jump.
                ;Shift left to double the request's value because the entries in the jumptable
                ;are two bytes each.
                
012A                            h2d_std_device:
012A 1A F9 [05]                         mov             A, [bRequest]
012C 3B    [04]                         asl             A
012D E6 40 [07]                         jacc    h2d_std_device_jumptable
                
012F                            h2d_std_interface:      
012F 1A F9 [05]                         mov             A, [bRequest]
0131 3B    [04]                         asl             A
0132 E6 54 [07]                         jacc    h2d_std_interface_jumptable
                
0134                            h2d_std_endpoint:
0134 1A F9 [05]                         mov             A, [bRequest]
0136 3B    [04]                         asl             A
0137 E6 6C [07]                         jacc    h2d_std_endpoint_jumptable
                
                ;I added this jump for set_report requests
0139                            h2d_class_interface:
0139 1A F9 [05]                         mov             A, [bRequest]
013B 3B    [04]                         asl             A
013C E6 74 [07]                         jacc    h2d_class_interface_jumptable
                
013E                            d2h_std_device:
013E 1A F9 [05]                         mov             A, [bRequest]
0140 3B    [04]                         asl             A
0141 E6 8E [07]                         jacc    d2h_std_device_jumptable
                
0143                            d2h_std_interface:
0143 1A F9 [05]                         mov             A, [bRequest]
0145 3B    [04]                         asl             A
0146 E6 A0 [07]                         jacc    d2h_std_interface_jumptable
                
0148                            d2h_std_endpoint:
0148 1A F9 [05]                         mov             A, [bRequest]
014A 3B    [04]                         asl             A
014B E6 B6 [07]                         jacc    d2h_std_endpoint_jumptable
                
                ;I added this jump for get_report requests
014D                            d2h_class_interface:
014D 1A F9 [05]                         mov             A, [bRequest]
014F 3B    [04]                         asl             A
0150 E6 D0 [07]                         jacc    d2h_class_interface_jumptable
                
                        ;;************ DEVICE REQUESTS **************
                
0152                    set_device_address:                                             ; SET ADDRESS
0152 19 00 [04]                 mov             A, ADDRESS_CHANGE_PENDING       ; set flag to indicate we
0154 31 27 [05]                 mov             [ep0_in_flag], A                        ; need to change address on
0156 1A FA [05]                 mov             A, [wValuelo]
0158 31 2E [05]                 mov             [pending_data], A
015A 83 7E [05]                 jmp             initialize_no_data_control
                
015C                    set_device_configuration:                               ; SET CONFIGURATION
015C 1A FA [05]                 mov             A, [wValuelo]
015E 16 01 [05]                 cmp             A, 01h
0160 A1 6E [05]                 jz              configure_device
                ;0 means unconfigure the device. 
0162                            unconfigure_device:                                     ; set device as unconfigured
0162 31 28 [05]                         mov             [configuration], A
0164 19 00 [04]                         mov             A, DISABLE                              ; disable endpoint 1
0166 2A 14 [05]                         iowr    ep1_mode
0168 19 01 [04]                         mov     A, EP0_INT                              ; turn off endpoint 1 interrupts
016A 2A 21 [05]                         iowr    endpoint_int
016C 81 8E [05]                         jmp             set_device_configuration_done
                ;1 means select configuration 1 (the only configuration option).
016E                            configure_device:                                       ; set device as configured
016E 31 28 [05]                         mov             [configuration], A
                
0170 1A 29 [05]                         mov             A, [ep1_stall]                  ; if endpoint 1 is stalled
0172 10 FF [04]                         and             A, FFh
0174 A1 7C [05]                         jz              ep1_nak_in_out
0176 19 03 [04]                                 mov             A, STALL_IN_OUT         ; set endpoint 1 mode to stall
0178 2A 14 [05]                                 iowr    ep1_mode
017A 81 80 [05]                                 jmp             ep1_set_int
017C                                    ep1_nak_in_out:
017C 19 01 [04]                                 mov             A, NAK_IN_OUT           ; otherwise set it to NAK in/out
017E 2A 14 [05]                                 iowr    ep1_mode
0180                                    ep1_set_int:
0180 19 03 [04]                         mov     A, EP0_INT | EP1_INT    ; enable endpoint 1 interrupt           
0182 2A 21 [05]                         iowr    endpoint_int
0184 19 00 [04]                         mov             A, 00h
0186 31 21 [05]                         mov             [ep1_data_toggle], A    ; reset the data toggle
0188 31 F0 [05]                         mov             [ep1_dmabuff0], A               ; reset endpoint 1 fifo values
018A 31 F1 [05]                         mov             [ep1_dmabuff1], A
018C 31 F2 [05]                         mov             [ep1_dmabuff2], A
018E                                    set_device_configuration_done:
018E 19 02 [04]                         mov             A, NO_CHANGE_PENDING
0190 31 27 [05]                         mov             [ep0_in_flag], A
0192 83 7E [05]                         jmp              initialize_no_data_control
                
                
0194                    get_device_status:                                              ; GET STATUS
0194 19 02 [04]                 mov             A, DEVICE_STATUS_LENGTH
0196 31 25 [05]                 mov             [maximum_data_count], A
0198 19 7A [04]                 mov             A, (device_status_wakeup_disabled - control_read_table)
019A 31 23 [05]                 mov             [data_start], A
019C 83 55 [05]                 jmp             initialize_control_read
                                
                
019E                    get_device_descriptor:                                  ; GET DESCRIPTOR
019E 1A FB [05]                 mov             A, [wValuehi]
                
01A0 3B    [04]                 asl             A
01A1 E6 E8 [07]                 jacc    get_device_descriptor_jumptable
                
01A3                            send_device_descriptor:
01A3 19 00 [04]                         mov             A, 00h                                  ; get device descriptor length
01A5 F8 00 [14]                         index   device_desc_table
01A7 31 25 [05]                         mov             [maximum_data_count], A
01A9 19 00 [04]                         mov             A, (device_desc_table - control_read_table)
01AB 31 23 [05]                         mov             [data_start], A
01AD 83 55 [05]                         jmp             initialize_control_read
                
01AF                            send_configuration_descriptor:
01AF 19 02 [04]                         mov             A, 02h
01B1 F8 12 [14]                         index   config_desc_table:
01B3 31 25 [05]                         mov             [maximum_data_count], A
01B5 19 12 [04]                         mov             A, (config_desc_table - control_read_table)
01B7 31 23 [05]                         mov             [data_start], A
01B9 83 55 [05]                         jmp             initialize_control_read
                
01BB                            send_string_descriptor:
01BB 1A FA [05]                         mov             A, [wValuelo]
01BD 3B    [04]                         asl             A
01BE E6 F4 [07]                         jacc    string_jumptable:
                
01C0                                    language_string:
01C0 19 00 [04]                                 mov             A, 00h
01C2 F8 87 [14]                                 index   ilanguage_string
01C4 31 25 [05]                                 mov             [maximum_data_count], A
01C6 19 87 [04]                                 mov             A, (ilanguage_string - control_read_table)
01C8 31 23 [05]                                 mov             [data_start], A
01CA 83 55 [05]                                 jmp             initialize_control_read
                
01CC                                    manufacturer_string:
01CC 19 00 [04]                                 mov             A, 00h
01CE F8 8B [14]                                 index   imanufacturer_string
01D0 31 25 [05]                                 mov             [maximum_data_count], A
01D2 19 8B [04]                                 mov             A, (imanufacturer_string - control_read_table)
01D4 31 23 [05]                                 mov             [data_start], A
01D6 83 55 [05]                                 jmp             initialize_control_read
                
01D8                                    product_string:
01D8 19 00 [04]                                 mov             A, 00h
01DA F8 BD [14]                                 index   iproduct_string
01DC 31 25 [05]                                 mov             [maximum_data_count], A
01DE 19 BD [04]                                 mov             A, (iproduct_string - control_read_table)
01E0 31 23 [05]                                 mov             [data_start], A
01E2 83 55 [05]                                 jmp             initialize_control_read
                
01E4                            send_interface_descriptor:
01E4 19 00 [04]                         mov             A, 00h                                  ; get interface descriptor length
01E6 F8 1B [14]                         index   interface_desc_table 
01E8 31 25 [05]                         mov             [maximum_data_count], A
01EA 19 1B [04]                         mov             A, (interface_desc_table - control_read_table)
01EC 31 23 [05]                         mov             [data_start], A
01EE 83 55 [05]                         jmp             initialize_control_read
                
01F0                            send_endpoint_descriptor:
01F0 19 00 [04]                         mov             A, 00h                                  ; get endpoint descriptor length
01F2 F8 2D [14]                         index   endpoint_desc_table
01F4 31 25 [05]                         mov             [maximum_data_count], A
01F6 19 2D [04]                         mov             A, (endpoint_desc_table - control_read_table)
01F8 31 23 [05]                         mov             [data_start], A
01FA 83 55 [05]                         jmp             initialize_control_read
                
                
01FC                            get_device_configuration:                       ; GET CONFIGURATION
01FC 19 01 [04]                         mov             A, DEVICE_CONFIG_LENGTH
01FE 20    [04]         NOP
01FF 1F    [04]         XPAGE
0200 31 25 [05]                         mov             [maximum_data_count], A
                
0202 1A 28 [05]                         mov             A, [configuration]              ; test configuration status
0204 10 FF [04]                         and             A, FFh
0206 A2 0E [05]                         jz              device_unconfigured
0208                                    device_configured:                              ; send configured status
0208 19 7C [04]                                 mov             A, (device_configured_table - control_read_table)
020A 31 23 [05]                                 mov             [data_start], A
020C 83 55 [05]                                 jmp             initialize_control_read
020E                                    device_unconfigured:                            ; send unconfigured status
020E 19 7D [04]                                 mov             A, (device_unconfigured_table - control_read_table)
0210 31 23 [05]                                 mov             [data_start], A
0212 83 55 [05]                                 jmp             initialize_control_read
                
                
                        ;;************ INTERFACE REQUESTS ***********
                
0214                    set_interface_interface:                                ; SET INTERFACE
0214 1A FA [05]                 mov             A, [wValuelo]
0216 16 00 [05]                 cmp             A, 00h                                          ; there are no alternate interfaces
0218 A2 1C [05]                 jz              alternate_supported                     ; for this device
021A                            alternate_not_supported:                        ; if the host requests any other
021A 83 89 [05]                         jmp             request_not_supported   ; alternate than 0, stall.      
021C                            alternate_supported:
021C 19 02 [04]                         mov             A, NO_CHANGE_PENDING
021E 31 27 [05]                         mov             [ep0_in_flag], A
0220 83 7E [05]                         jmp             initialize_no_data_control
                
                
0222                    get_interface_status:                                   ; GET STATUS
0222 19 02 [04]                 mov             A, INTERFACE_STATUS_LENGTH
0224 31 25 [05]                 mov             [maximum_data_count], A
                
0226 19 82 [04]                 mov             A, (interface_status_table - control_read_table)
0228 31 23 [05]                 mov             [data_start], A
022A 83 55 [05]                 jmp             initialize_control_read
                                
                
022C                    get_interface_interface:                                ; GET INTERFACE
022C 19 01 [04]                 mov             A, INTERFACE_ALTERNATE_LENGTH
022E 31 25 [05]                 mov             [maximum_data_count], A
0230 19 84 [04]                 mov             A, (interface_alternate_table - control_read_table)
0232 31 23 [05]                 mov             [data_start], A
0234 83 55 [05]                 jmp             initialize_control_read
                
                
0236                    set_interface_idle:                                             ; SET IDLE
0236 1A FB [05]                 mov             A, [wValuehi]                           ; test if new idle time 
0238 16 00 [05]                 cmp             A, 00h                                          ; disables idle timer
                
023A A2 4A [05]                 jz              idle_timer_disable
                
023C 1A 30 [05]                 mov             A, [idle_timer]                         ; test if less than 4ms left
023E 16 01 [05]                 cmp             A, 01h
0240 A2 4E [05]                 jz              set_idle_last_not_expired
                
0242 1A FB [05]                 mov             A, [wValuehi]                           ; test if time left less than
0244 08 30 [06]                 sub             A, [idle_timer]                         ; new idle value
0246 D2 5E [05]                 jnc             set_idle_new_timer_less
                
0248 82 6A [05]                 jmp             set_idle_normal
                
024A                            idle_timer_disable:
024A 31 2A [05]                         mov             [idle], A                               ; disable idle timer
024C 82 74 [05]                         jmp             set_idle_done
                
024E                            set_idle_last_not_expired:
024E 19 02 [04]                         mov             A, EVENT_PENDING                ; send report immediately
0250 31 2D [05]                         mov             [event_machine], A
0252 19 00 [04]                         mov             A, 00h                                  ; reset idle prescaler
0254 31 31 [05]                         mov             [idle_prescaler], A
0256 1A FB [05]                         mov             A, [wValuehi]                   ; set new idle value
0258 31 30 [05]                         mov             [idle_timer], A
025A 31 2A [05]                         mov             [idle], A
025C 82 74 [05]                         jmp             set_idle_done
                
025E                            set_idle_new_timer_less:                        
025E 19 00 [04]                         mov             A, 00h
0260 31 31 [05]                         mov             [idle_prescaler], A             ; reset idle prescaler
0262 1A FB [05]                         mov             A, [wValuehi]
0264 31 30 [05]                         mov             [idle_timer], A                 ; update idle time value
0266 31 2A [05]                         mov             [idle], A
0268 82 74 [05]                         jmp             set_idle_done
                
026A                            set_idle_normal:
026A 19 00 [04]                         mov             A, 00h                                  ; reset idle prescaler
026C 31 31 [05]                         mov             [idle_prescaler], A
026E 1A FB [05]                         mov             A, [wValuehi]                   ; update idle time value
0270 31 30 [05]                         mov             [idle_timer], A
0272 31 2A [05]                         mov             [idle], A
                
0274                            set_idle_done:
0274 19 02 [04]                         mov             A, NO_CHANGE_PENDING    ; respond with no-data control
0276 31 27 [05]                         mov             [ep0_in_flag], A                ; transaction
0278 83 7E [05]                         jmp             initialize_no_data_control
                
                
027A                    set_interface_protocol:                                 ; SET PROTOCOL
027A 1A FA [05]                 mov             A, [wValuelo]
027C 31 2B [05]                 mov             [protocol], A                           ; set protocol value
027E 19 02 [04]                 mov             A, NO_CHANGE_PENDING
0280 31 27 [05]                 mov             [ep0_in_flag], A                        ; respond with no-data control
0282 83 7E [05]                 jmp             initialize_no_data_control      ; transaction
                
                
0284                    get_report:                                     ; GET REPORT
                
0284 19 02 [04]                 mov             A, TRANS_CONTROL_READ           ; set transaction type to control read
0286 31 33 [05]                 mov             [ep0_transtype], A
                
0288 19 80 [04]                 mov             A, DATA_TOGGLE                          ; set data toggle to DATA ONE
028A 31 22 [05]                 mov             [ep0_data_toggle], A
                ;Send NAK in response to any new INs or OUTs while writing to the buffers.
028C 19 01 [04]                 mov             A, NAK_IN_OUT                           ; clear setup bit to write to
028E 2A 12 [05]                 iowr    ep0_mode                                        ; endpoint fifo
                
                ;Get the report type (Input or Feature) from the low byte of the Value field.
0290 1A FB [05]                 mov A, [wValuehi]
                                ;Double the value for the jump table
0292 3B    [04]                 asl A
0293 E7 08 [07]                 jacc in_report_type_jumptable
                
0295            send_input_report:
                
                
                ;If the host requests the Input report with a control transfer, 
                ;copy the Input report data from the Input report buffer to Endpoint 0.
0295 1A 48 [05]                 mov             A, [output_report_byte_0]
0297 31 F8 [05]                 mov             [ep0_dmabuff0], A
                
0299 1A F1 [05]                 mov             A, [output_report_byte_1]
029B 31 F9 [05]                 mov             [ep0_dmabuff1], A
                
029D 19 02 [04]                 mov             A, CONTROL_READ_DATA            ; set state machine state
029F 31 26 [05]                 mov             [ep0_in_machine], A                     
02A1 1C 02 [04]                 mov             X, 02h                                          ; set number of bytes to transfer to 2
02A3 83 B2 [05]                 jmp             dmabuffer_load_done                     ; jump to finish transfer
                                
                        
02A5            send_feature_report:
                
                ;If the host requests a Feature report, 
                ;copy the Feature report data from the Feature report buffer to Endpoint 0.
02A5 1A 38 [05]                 mov             A, [feature_report_byte_0]
02A7 31 F8 [05]                 mov             [ep0_dmabuff0], A
                
02A9 1A F1 [05]                 mov             A, [feature_report_byte_1]
02AB 31 F9 [05]                 mov             [ep0_dmabuff1], A
                
02AD 19 02 [04]                 mov             A, CONTROL_READ_DATA            ; set state machine state
02AF 31 26 [05]                 mov             [ep0_in_machine], A                     
02B1 1C 02 [04]                 mov             X, 02h                                          ; set number of bytes to transfer to 2
02B3 83 B2 [05]                 jmp             dmabuffer_load_done                     ; jump to finish transfer
                
                
                
02B5                    get_interface_idle:                                             ; GET IDLE
02B5 19 80 [04]                 mov             A, DATA_TOGGLE                          ; set data toggle to DATA ONE
02B7 31 22 [05]                 mov             [ep0_data_toggle], A
02B9 19 01 [04]                 mov             A, NAK_IN_OUT                           ; clear setup bit to write to
02BB 2A 12 [05]                 iowr    ep0_mode                                        ; endpoint fifo
                
02BD 1A 2A [05]                 mov             A, [idle]                                       ; copy over idle time
02BF 31 F8 [05]                 mov             [ep0_dmabuff0], A
                
02C1 19 02 [04]                 mov             A, CONTROL_READ_DATA            ; set state machine state
02C3 31 26 [05]                 mov             [ep0_in_machine], A                     
02C5 1C 01 [04]                 mov             X, 01h                                          ; set number of byte to transfer to 3
02C7 83 B2 [05]                 jmp             dmabuffer_load_done                     ; jump to finish transfer
                
                        
02C9                    get_interface_protocol:                                 ; GET PROTOCOL
02C9 19 01 [04]                 mov             A, INTERFACE_PROTOCOL_LENGTH
02CB 31 25 [05]                 mov             [maximum_data_count], A         ; get offset of device descriptor table
02CD 1A 2B [05]                 mov             A, [protocol]
02CF 10 01 [04]                 and             A, 01h
02D1 A2 D9 [05]                 jz              boot_protocol
02D3                            report_protocol:
02D3 19 86 [04]                         mov             A, (interface_report_protocol - control_read_table)
02D5 31 23 [05]                         mov             [data_start], A
02D7 83 55 [05]                         jmp             initialize_control_read ; get ready to send data
02D9                            boot_protocol:
02D9 19 85 [04]                         mov             A, (interface_boot_protocol - control_read_table)
02DB 31 23 [05]                         mov             [data_start], A
02DD 83 55 [05]                         jmp             initialize_control_read ; get ready to send data
                
                
02DF                    get_interface_hid:
02DF 1A FB [05]                 mov             A, [wValuehi]
02E1 16 21 [05]                 cmp             A, 21h
02E3 A2 EB [05]                 jz              get_interface_hid_descriptor
02E5 16 22 [05]                 cmp             A, 22h
02E7 A2 F7 [05]                 jz              get_interface_hid_report
02E9 83 89 [05]                 jmp             request_not_supported
                
02EB                    get_interface_hid_descriptor:                   ; GET HID CLASS DESCRIPTOR
02EB 19 00 [04]                 mov             A, 00h                                          ; get hid decriptor length
02ED F8 24 [14]                 index   hid_desc_table
02EF 31 25 [05]                 mov             [maximum_data_count], A         ; get offset of device descriptor table
02F1 19 24 [04]                 mov             A, (hid_desc_table - control_read_table)
02F3 31 23 [05]                 mov             [data_start], A
02F5 83 55 [05]                 jmp             initialize_control_read         ; get ready to send data
                
                
02F7                    get_interface_hid_report:                               ; GET HID REPORT DESCRIPTOR
02F7 19 07 [04]                 mov             A, 07h                                          ; get hid report descriptor length
02F9 F8 24 [14]                 index   hid_desc_table
02FB 31 25 [05]                 mov             [maximum_data_count], A         ; get offset of device descriptor table
02FD 19 34 [04]                 mov             A, (hid_report_desc_table - control_read_table)
02FF 1F    [04]         XPAGE
0300 31 23 [05]                 mov             [data_start], A
0302 83 55 [05]                 jmp             initialize_control_read         ; get ready to send data
                
                
                        ;;************ ENDPOINT REQUESTS ************
                
0304                    clear_endpoint_feature:                                 ; CLEAR FEATURE
0304 1A FA [05]                 mov             A, [wValuelo]
0306 16 00 [05]                 cmp             A, ENDPOINT_STALL
0308 B3 89 [05]                 jnz             request_not_supported           
030A 19 00 [04]                 mov             A, 00h                                          ; clear endpoint 1 stall
030C 31 29 [05]                 mov             [ep1_stall], A
030E 19 02 [04]                 mov             A, NO_CHANGE_PENDING            ; respond with no-data control
0310 31 27 [05]                 mov             [ep0_in_flag], A
0312 83 7E [05]                 jmp             initialize_no_data_control
                
                
0314                    set_endpoint_feature:                                   ; SET FEATURE
0314 1A FA [05]                 mov             A, [wValuelo]
0316 16 00 [05]                 cmp             A, ENDPOINT_STALL
0318 B3 89 [05]                 jnz             request_not_supported           
031A 19 FF [04]                 mov             A, FFh                                          ; stall endpoint 1
031C 31 29 [05]                 mov             [ep1_stall], A
031E 19 02 [04]                 mov             A, NO_CHANGE_PENDING            ; respond with no-data control
0320 31 27 [05]                 mov             [ep0_in_flag], A
0322 83 7E [05]                 jmp             initialize_no_data_control
                
0324                    get_endpoint_status:                                    ; GET STATUS
0324 19 02 [04]                 mov             A, ENDPOINT_STALL_LENGTH
0326 31 25 [05]                 mov             [maximum_data_count], A
0328 1A 29 [05]                 mov             A, [ep1_stall]                          ; test if endpoint 1 stalled
032A 10 FF [04]                 and             A, FFh
032C B3 34 [05]                 jnz             endpoint_stalled
032E                            endpoint_not_stalled:                           ; send no-stall status
032E 19 7E [04]                         mov             A, (endpoint_nostall_table - control_read_table)
0330 31 23 [05]                         mov             [data_start], A
0332 83 55 [05]                         jmp             initialize_control_read
0334                            endpoint_stalled:                                       ; send stall status
0334 19 80 [04]                         mov             A, (endpoint_stall_table - control_read_table)
0336 31 23 [05]                         mov             [data_start], A
0338 83 55 [05]                         jmp             initialize_control_read
                                
                
                        ;;************ CLASS INTERFACE REQUESTS ************
                
033A                    set_report:                                                     ; SET REPORT
                ;Find out how many bytes to read in the Out transaction(s) that will follow.
                ;This value is in WLengthlo and WLengthhi.
                ;Save the length in data_count.
033A 1A FE [05]                 mov A, [wLengthlo]
033C 31 24 [05]                 mov [data_count], A
                ;The Output reports are 2 bytes, so wLengthhi is unused.
033E 19 00 [04]                 mov A, 0
0340 31 FF [05]                 mov [wLengthhi], A
                
                ;Unlock the counter register so it can be updated with the 
                ;number of bytes in the data stage
0342 29 11 [05]                 iord    ep0_count
                
                ;Get the report type (Output or Feature) from the high byte of the Value field.
0344 1A FB [05]                 mov A, [wValuehi]
                                ;Double the value for the jump table
0346 3B    [04]                 asl A
0347 E7 00 [07]                 jacc out_report_type_jumptable
                
0349            get_output_report:
                
                ;Receive an Output report from the host.
                
                ;output_or_feature indicates the report type.
0349 19 00 [04]                 mov A, 0
034B 31 37 [05]                 mov [output_or_feature], A
                
                
                
                ;Enable receiving data in an Out transaction.
034D 83 6F [05]                 jmp initialize_control_write
                
034F            get_feature_report:
                
                ;receive a Feature report from the host.
                
                
                
                ;output_or_feature indicates the report type.
034F 19 01 [04]                 mov A, 1
0351 31 37 [05]                 mov [output_or_feature], A
                
                ;Enable receiving data in an Out transaction.
0353 83 6F [05]                 jmp initialize_control_write
                ;my code **************************************************
                
                ;;***************** CONTROL READ TRANSACTION **************
                
0355                    initialize_control_read:
0355 19 02 [04]                 mov             A, TRANS_CONTROL_READ           ; set transaction type to control read
0357 31 33 [05]                 mov             [ep0_transtype], A
                
0359 19 80 [04]                 mov             A, DATA_TOGGLE                          ; set data toggle to DATA ONE
035B 31 22 [05]                 mov             [ep0_data_toggle], A
                
                                ; if wLengthhi == 0
035D 1A FF [05]                 mov             A, [wLengthhi]                          ; find lesser of requested and maximum
035F 16 00 [05]                 cmp             A, 00h
0361 B3 6D [05]                 jnz             initialize_control_read_done
                                ; and wLengthlo < maximum_data_count
0363 1A FE [05]                 mov             A, [wLengthlo]                          ; find lesser of requested and maximum
0365 17 25 [07]                 cmp             A, [maximum_data_count]         ; response lengths
0367 D3 6D [05]                 jnc             initialize_control_read_done
                                ; then maximum_data_count >= wLengthlo
0369 1A FE [05]                 mov             A, [wLengthlo]
036B 31 25 [05]                 mov             [maximum_data_count], A
036D                            initialize_control_read_done:
036D 83 96 [05]                         jmp             control_read_data_stage ; send first packet
                
                
                ;;***************** CONTROL WRITE TRANSACTION *************
                
036F                    initialize_control_write:
036F 19 04 [04]                 mov             A, TRANS_CONTROL_WRITE          ; set transaction type to control write
                ;The firmware uses the value in ep0_transtype to decide how to respond
                ;to a token packet.
0371 31 33 [05]                 mov             [ep0_transtype], A
                
0373 19 80 [04]                 mov             A, DATA_TOGGLE                          ; set accepted data toggle
0375 31 22 [05]                 mov             [ep0_data_toggle], A
                
                ;Send ACK in response to OUT packets, 
                ;which will contain the Control Write data.
                ;Send NAK in response to IN packets (not expected).
0377 19 0B [04]                 mov             A, ACK_OUT_NAK_IN                       ; set mode
0379 2A 12 [05]                 iowr    ep0_mode
                
                ;Return from the Endpoint 0 ISR.
037B 2B    [04]                 pop             A
037C 2C    [04]                 pop             X
037D 73    [08]                 reti
                
                ;;***************** NO DATA CONTROL TRANSACTION ***********
                
037E                    initialize_no_data_control:
037E 19 06 [04]                 mov             A, TRANS_NO_DATA_CONTROL        ; set transaction type to no data control
0380 31 33 [05]                 mov             [ep0_transtype], A
                
0382 19 06 [04]                 mov             A, STATUS_IN_ONLY                       ; set SIE for STATUS IN mode
0384 2A 12 [05]                 iowr    ep0_mode
0386 2B    [04]                 pop             A
0387 2C    [04]                 pop             X
0388 73    [08]                 reti
                
                
                ;;***************** UNSUPPORTED TRANSACTION ***************
                
0389                    request_not_supported:
0389 29 12 [05]                 iord    ep0_mode
038B 19 03 [04]                 mov     A, STALL_IN_OUT                                 ; send a stall to indicate that the request
038D 2A 12 [05]                 iowr    ep0_mode                                        ; is not supported
038F 2B    [04]                 pop     A
0390 2C    [04]                 pop     X
0391 73    [08]                 reti
                
                
                ;**********************************************************
                
                        ;**********************************
                        ; IN - CONTROL READ DATA STAGE
                        ;        - CONTROL WRITE STATUS STAGE
                        ;        - NO DATA CONTROL STATUS STAGE
                
0392                    ep0_in_received:
0392 1A 33 [05]         mov             A, [ep0_transtype]
0394 E6 D8 [07]         jacc    ep0_in_jumptable
                
                
                        ;**********************************
                
0396                    control_read_data_stage:
                
0396 1C 00 [04]                 mov             X, 00h
                
0398 1A 25 [05]                 mov             A, [maximum_data_count]
039A 16 00 [05]                 cmp             A, 00h                                          ; has all been sent
039C A3 B2 [05]                 jz              dmabuffer_load_done                     
                
039E                            dmabuffer_load:
039E 40    [04]                         mov             A, X                                    ; check if 8 byte ep0 dma
039F 16 08 [05]                         cmp             A, 08h                                  ; buffer is full
03A1 A3 B2 [05]                         jz              dmabuffer_load_done
03A3 1A 23 [05]                         mov             A, [data_start]                 ; read data from desc. table
03A5 F8 00 [14]                         index   control_read_table
03A7 32 F8 [06]                         mov             [X + ep0_dmabuff0], A
                
03A9 22    [04]                         inc             X                                               ; increment buffer offset
03AA 23 23 [07]                         inc             [data_start]                    ; increment descriptor table pointer
03AC 27 25 [07]                         dec             [maximum_data_count]    ; decrement number of bytes requested
03AE A3 B2 [05]                         jz              dmabuffer_load_done
03B0 83 9E [05]                         jmp             dmabuffer_load                  ; loop to load more data
03B2                                    dmabuffer_load_done:
                        
03B2 29 11 [05]                 iord    ep0_count                                       ; unlock counter register
03B4 40    [04]                 mov             A, X                                            ; find number of bytes loaded
03B5 0E 22 [06]                 or              A, [ep0_data_toggle]            ; or data toggle
03B7 2A 11 [05]                 iowr    ep0_count                                       ; write ep0 count register
                
03B9 19 0F [04]                 mov             A, ACK_IN_STATUS_OUT            ; set endpoint mode to ack next IN
03BB 2A 12 [05]                 iowr    ep0_mode                                        ; or STATUS OUT
                                        
03BD 19 80 [04]                 mov             A, DATA_TOGGLE                          ; toggle data toggle
03BF 37 22 [07]                 xor             [ep0_data_toggle], A
                
03C1 2B    [04]                 pop             A
03C2 2C    [04]                 pop             X
03C3 73    [08]                 reti
                
                
                        ;**********************************
                
03C4                    control_write_status_stage:
                ;Jump here if the device has received an IN token packet 
                ;with ep0_transtype = TRANS_CONTROL_WRITE
                ;The device has sent a 0-byte In data packet to complete the transfer
                ;because ep0_mode was set to Status_In_Only at the end of the data stage. 
                
03C4 19 02 [04]                 mov             A, STATUS_OUT_ONLY
03C6 2A 12 [05]                 iowr    ep0_mode
                
03C8 19 00 [04]         mov             A, TRANS_NONE
03CA 31 33 [05]         mov             [ep0_transtype], A
                
03CC 2B    [04]                 pop             A
03CD 2C    [04]                 pop             X
                
03CE 73    [08]                 reti
                
                
                        ;**********************************
                
03CF                    no_data_control_status_stage:
03CF 1A 27 [05]                 mov             A, [ep0_in_flag]                ; end of no-data control transaction 
03D1 16 00 [05]                 cmp             A, ADDRESS_CHANGE_PENDING
03D3 B3 DB [05]                 jnz             no_data_status_done
                
03D5                            change_address:
03D5 1A 2E [05]                         mov             A, [pending_data]       ; change the device address if this
03D7 0D 80 [04]                         or              A, ADDRESS_ENABLE       ; data is pending
03D9 2A 10 [05]                         iowr    usb_address
                
                
03DB                            no_data_status_done:                    ; otherwise set to stall in/out until
03DB 19 03 [04]                         mov             A, STALL_IN_OUT         ; a new setup
03DD 2A 12 [05]                         iowr    ep0_mode
                
03DF 19 00 [04]                         mov             A, TRANS_NONE
03E1 31 33 [05]                         mov             [ep0_transtype], A
                
03E3 2B    [04]                         pop             A
03E4 2C    [04]                         pop             X
03E5 73    [08]                         reti
                
                
                ;**********************************************************
                
                        ;**********************************
                        ; OUT - CONTROL READ STATUS STAGE
                        ;         - CONTROL WRITE DATA STAGE
                        ;         - ERROR DURING NO DATA CONTROL TRANSACTION
                
03E6                    ep0_out_received:
                
                ;ep0_transtype was set during a previous transaction in the transfer.
03E6 1A 33 [05]         mov             A, [ep0_transtype]
03E8 E6 E0 [07]         jacc    ep0_out_jumptable
                
                        ;**********************************
                
03EA                    control_read_status_stage:
                
03EA 19 06 [04]                 mov             A, STATUS_IN_ONLY
03EC 2A 12 [05]                 iowr    ep0_mode
                
03EE 19 00 [04]                 mov             A, TRANS_NONE
03F0 31 33 [05]                 mov             [ep0_transtype], A
                
03F2 2B    [04]                 pop             A
03F3 2C    [04]                 pop             X
03F4 73    [08]                 reti    
                
                
                        ;**********************************
                
03F5                    control_write_data_stage:
                ;If the data-valid bit isn't set, we're done with the data stage.
                ;(logo.asm used mov A, ep0_count (incorrect) instead of iord here.)
03F5 29 11 [05]                 iord            ep0_count                                       ; check that data is valid
03F7 10 40 [04]                 and             A, DATA_VALID
03F9 A4 30 [05]                 jz              control_write_data_stage_done
                
                ;(logo.asm used mov A, ep0_count (incorrect) instead of iord here.)
03FB 29 11 [05]                 iord            ep0_count                                       ;check data toggle
03FD 10 80 [04]                 and             A, DATA_TOGGLE
03FF 1F    [04]         XPAGE
0400 14 22 [06]                 xor             A, [ep0_data_toggle]
0402 B4 30 [05]                 jnz             control_write_data_stage_done
                
                ;The only supported control_write transfer is set_report.
                
                ;Is it an Output or Feature report?
0404 19 00 [04]                         mov             A, 0
0406 17 37 [07]                         cmp             A, [output_or_feature]
0408 A4 14 [05]                         jz              output_report
                
040A            feature_report:
                
040A 1A F8 [05]                         mov             A, [ep0_dmabuff0]
040C 31 38 [05]                         mov             [feature_report_byte_0], A
040E 1A F9 [05]                         mov             A, [ep0_dmabuff1]
0410 31 F1 [05]                         mov             [feature_report_byte_1], A
                
0412 84 28 [05]                         jmp             data_toggle
0414            output_report:
                
                ;Copy the report's two bytes to the data memory.
                
0414 1A F8 [05]                         mov             A, [ep0_dmabuff0]
0416 31 50 [05]                         mov             [port0_data_temp]     , A
0418 31 48 [05]                         mov             [output_report_byte_0], A
041A 2A 00 [05]                         iowr            port0
                ;                       mov             [input_report_byte_0], A
041C 1A F9 [05]                         mov             A, [ep0_dmabuff1]
041E 31 51 [05]                         mov             [port1_data_temp]     , A
0420 31 F1 [05]                         mov             [output_report_byte_1], A
0422 2A 01 [05]                         iowr            port1
                ;                       mov             [input_report_byte_1], A
                
                
                
                
                
                ;Set output_report_received to 1 to indicate there's a new report.
0424 19 01 [04]                         mov             A, 01h
0426 31 36 [05]                         mov             [output_report_received], A
                
                
                
                
                
                
                
                
0428            data_toggle:
                
                ;Toggle the data-toggle bit.
0428 19 80 [04]                 mov             A, DATA_TOGGLE
042A 37 22 [07]                 xor             [ep0_data_toggle], A
                
                ;If all of the data has been received,
                ;configure Endpoint 0 to send a 0-byte data packet in response
                ;to an IN packet (the transfer's status phase)
                ;and to Stall an Out packet.
                ;To do: add the ability to use > 1 data transaction.
                
042C 19 06 [04]                 mov             A, STATUS_IN_ONLY
042E 2A 12 [05]                 iowr            ep0_mode
                
0430                            control_write_data_stage_done:
                
                
0430 2B    [04]                 pop             A
0431 2C    [04]                 pop             X
0432 73    [08]                 reti
                
                                
                        ;**********************************
                
0433                    no_data_control_error:  
0433 19 03 [04]                 mov             A, STALL_IN_OUT
0435 2A 12 [05]                 iowr    ep0_mode
                
0437 19 00 [04]                 mov             A, TRANS_NONE
0439 31 33 [05]                 mov             [ep0_transtype], A
                
043B 2B    [04]                 pop             A
043C 2C    [04]                 pop             X
043D 73    [08]                 reti
                
                
                        
                ;*******************************************************
                ;
                ;       Interrupt handler: endpoint1
                ;       Purpose: This interrupt routine handles the specially
                ;                reserved data endpoint 1.  This
                ;                interrupt happens every time a host sends an
                ;                IN on endpoint 1.  The data to send (NAK or 3
                ;                byte packet) is already loaded, so this routine
                ;                just prepares the dma buffers for the next packet
                ;
                ;*******************************************************
                
043E            endpoint1:
043E 2D    [05]         push    A
043F 29 14 [05]         iord    ep1_mode
                ; If the interrupt was due to sending a NAK, 
                ; exit the ISR.
0441 10 10 [04]         and     A, EP_ACK
0443 A4 59 [05]         jz           endpoint1_NAK
                
                ; Otherwise, toggle the data toggle for the next transaction.
0445 19 80 [04]         mov             A, 80h
0447 37 21 [07]         xor             [ep1_data_toggle], A
                
0449 19 00 [04]         mov             A, NO_EVENT_PENDING                             ; clear pending events
044B 31 2D [05]         mov             [event_machine], A 
                
                        ; set response
044D 1A 29 [05]         mov             A, [ep1_stall]                                  ; if endpoint is set to stall, then set
044F 16 FF [05]         cmp             A, FFh                                                  ; mode to stall
0451 B4 59 [05]         jnz             endpoint1_NAK
0453 19 03 [04]                 mov             A, STALL_IN_OUT
0455 2A 14 [05]                 iowr    ep1_mode
0457 84 5D [05]         jmp             endpoint1_done
                
                
0459            endpoint1_NAK:
                ; If the host returned ACK, the SIE set the ACK bit 
                ; in the epP1_mode register. Clear the ACK bit.
                ; The endpoint mode remains NAK_IN.
0459 19 0C [04]         mov     A, NAK_IN
045B 2A 14 [05]         iowr    ep1_mode        
045D                    endpoint1_done:
045D 2B    [04]                 pop             A
045E 73    [08]                 reti
                
                        
                ;**********************************************************
                ;       JUMP TABLES
                ;**********************************************************
                
045F            XPAGEOFF
                
0600            ORG             600h
                
                                ; bmRequestTypes commented out are not used for this device,
                                ; but may be used for your device.  They are kept here as
                                ; an example of how to use this jumptable.
                
0600                            bmRequestType_jumptable:
0600 81 2A [05]                         jmp             h2d_std_device                  ; 00
0602 81 2F [05]                         jmp             h2d_std_interface               ; 01    
0604 81 34 [05]                         jmp             h2d_std_endpoint                ; 02    
0606 83 89 [05]                         jmp             request_not_supported   ; h2d_std_other                 03      
0608 83 89 [05]                         jmp             request_not_supported   ; h2d_class_device              04      
060A 81 39 [05]                         jmp             h2d_class_interface     ;05     
060C 83 89 [05]                         jmp             request_not_supported   ; h2d_class_endpoint    06      
060E 83 89 [05]                         jmp             request_not_supported   ; h2d_class_other               07      
0610 83 89 [05]                         jmp             request_not_supported   ; h2d_vendor_device             08      
0612 83 89 [05]                         jmp             request_not_supported   ; h2d_vendor_interface  09      
0614 83 89 [05]                         jmp             request_not_supported   ; h2d_vendor_endpoint   0A      
0616 83 89 [05]                         jmp             request_not_supported   ; h2d_vendor_other              0B      
0618 83 89 [05]                         jmp             request_not_supported   ; 0C    
061A 83 89 [05]                         jmp             request_not_supported   ; 0D    
061C 83 89 [05]                         jmp             request_not_supported   ; 0E    
061E 83 89 [05]                         jmp             request_not_supported   ; 0F    
0620 81 3E [05]                         jmp             d2h_std_device                  ; 10    
0622 81 43 [05]                         jmp             d2h_std_interface               ; 11    
0624 81 48 [05]                         jmp             d2h_std_endpoint                ; 12    
0626 83 89 [05]                         jmp             request_not_supported   ; d2h_std_other                 13      
0628 83 89 [05]                         jmp             request_not_supported   ; d2h_class_device              14      
062A 81 4D [05]                         jmp             d2h_class_interface     ; 15    
062C 83 89 [05]                         jmp             request_not_supported   ; d2h_class_endpoint    16      
062E 83 89 [05]                         jmp             request_not_supported   ; d2h_class_other               17      
0630 83 89 [05]                         jmp             request_not_supported   ; d2h_vendor_device             18      
0632 83 89 [05]                         jmp             request_not_supported   ; d2h_vendor_interface  19      
0634 83 89 [05]                         jmp             request_not_supported   ; d2h_vendor_endpoint   1A      
0636 83 89 [05]                         jmp             request_not_supported   ; d2h_vendor_other              1B      
0638 83 89 [05]                         jmp             request_not_supported   ; 1C    
063A 83 89 [05]                         jmp             request_not_supported   ; 1D    
063C 83 89 [05]                         jmp             request_not_supported   ; 1E    
063E 83 89 [05]                         jmp             request_not_supported   ; 1F    
                
0640                            h2d_std_device_jumptable:
0640 83 89 [05]                         jmp             request_not_supported   ; 00
0642 83 89 [05]                         jmp             request_not_supported   ; 01
0644 83 89 [05]                         jmp             request_not_supported   ; 02
0646 83 89 [05]                         jmp             request_not_supported           ; 03
0648 83 89 [05]                         jmp             request_not_supported   ; 04
064A 81 52 [05]                         jmp             set_device_address              ; 05
064C 83 89 [05]                         jmp             request_not_supported   ; 06
                
064E 83 89 [05]                         jmp             request_not_supported   ; set_device_descriptor         07
0650 83 89 [05]                         jmp             request_not_supported   ; 08
0652 81 5C [05]                         jmp             set_device_configuration; 09
                
0654                            h2d_std_interface_jumptable:
0654 83 89 [05]                         jmp             request_not_supported   ; 00
0656 83 89 [05]                         jmp             request_not_supported   ; clear_interface_feature 01
0658 83 89 [05]                         jmp             request_not_supported   ; 02
065A 83 89 [05]                         jmp             request_not_supported   ; set_interface_feature  03
                
065C 83 89 [05]                         jmp             request_not_supported   ; 04
065E 83 89 [05]                         jmp             request_not_supported   ; 05
0660 83 89 [05]                         jmp             request_not_supported   ; 06
0662 83 89 [05]                         jmp             request_not_supported   ; 07
0664 83 89 [05]                         jmp             request_not_supported   ; 08
0666 83 89 [05]                         jmp             request_not_supported   ; 09
0668 83 89 [05]                         jmp             request_not_supported   ; 0A
066A 82 14 [05]                         jmp             set_interface_interface ; 0B
                
066C                            h2d_std_endpoint_jumptable:
066C 83 89 [05]                         jmp             request_not_supported   ; 00
066E 83 04 [05]                         jmp             clear_endpoint_feature  ; 01
0670 83 89 [05]                         jmp             request_not_supported   ; 02
0672 83 14 [05]                         jmp             set_endpoint_feature    ; 03
                
                ;h2d_class_interface_jumptable was added to logo.asm
                ;Host-to-device HID-specific requests
0674                            h2d_class_interface_jumptable:
0674 83 89 [05]                         jmp             request_not_supported   ; 00
0676 83 89 [05]                         jmp             request_not_supported   ; 01
0678 83 89 [05]                         jmp             request_not_supported   ; 02
067A 83 89 [05]                         jmp             request_not_supported   ; 03
067C 83 89 [05]                         jmp             request_not_supported   ; 04
067E 83 89 [05]                         jmp             request_not_supported   ; 05
0680 83 89 [05]                         jmp             request_not_supported   ; 06
0682 83 89 [05]                         jmp             request_not_supported   ; 07
0684 83 89 [05]                         jmp             request_not_supported   ; 08
                
0686 83 3A [05]                         jmp             set_report                      ; 09
0688 83 89 [05]                         jmp             request_not_supported   ; 09
                
068A 83 89 [05]                         jmp             request_not_supported   ; set_idle      ; 0A
068C 83 89 [05]                         jmp             request_not_supported   ; set_protocol  ; 0B
                
068E                            d2h_std_device_jumptable:
068E 81 94 [05]                         jmp             get_device_status               ; 00
0690 83 89 [05]                         jmp             request_not_supported   ; 01
0692 83 89 [05]                         jmp             request_not_supported   ; 02
0694 83 89 [05]                         jmp             request_not_supported   ; 03
0696 83 89 [05]                         jmp             request_not_supported   ; 04
0698 83 89 [05]                         jmp             request_not_supported   ; 05
069A 81 9E [05]                         jmp             get_device_descriptor   ; 06
069C 83 89 [05]                         jmp             request_not_supported   ; 07
069E 81 FC [05]                         jmp             get_device_configuration; 08
                
06A0                            d2h_std_interface_jumptable:
06A0 82 22 [05]                         jmp             get_interface_status    ; 00
06A2 83 89 [05]                         jmp             request_not_supported   ; 01
06A4 83 89 [05]                         jmp             request_not_supported   ; 02
06A6 83 89 [05]                         jmp             request_not_supported   ; 03
06A8 83 89 [05]                         jmp             request_not_supported   ; 04
06AA 83 89 [05]                         jmp             request_not_supported   ; 05
06AC 82 DF [05]                         jmp             get_interface_hid               ; 06
06AE 83 89 [05]                         jmp             request_not_supported   ; 07
06B0 83 89 [05]                         jmp             request_not_supported   ; 08
06B2 83 89 [05]                         jmp             request_not_supported   ; 09
06B4 82 2C [05]                         jmp             get_interface_interface ; 0A
                        
06B6                            d2h_std_endpoint_jumptable:
06B6 83 24 [05]                         jmp             get_endpoint_status             ; 00
06B8 83 89 [05]                         jmp             request_not_supported   ; 01
06BA 83 89 [05]                         jmp             request_not_supported   ; 02
06BC 83 89 [05]                         jmp             request_not_supported   ; 03
06BE 83 89 [05]                         jmp             request_not_supported   ; 04
06C0 83 89 [05]                         jmp             request_not_supported   ; 05
06C2 83 89 [05]                         jmp             request_not_supported   ; 06
06C4 83 89 [05]                         jmp             request_not_supported   ; 07
06C6 83 89 [05]                         jmp             request_not_supported   ; 08
06C8 83 89 [05]                         jmp             request_not_supported   ; 09
06CA 83 89 [05]                         jmp             request_not_supported   ; 0A
06CC 83 89 [05]                         jmp             request_not_supported   ; 0B
06CE 83 89 [05]                         jmp             request_not_supported   ; synch frame 0C
                
                ;Device-to-host HID-specific requests
06D0                            d2h_class_interface_jumptable:
06D0 83 89 [05]                         jmp             request_not_supported   ; 00
06D2 82 84 [05]                         jmp             get_report      ; 01
06D4 83 89 [05]                         jmp             request_not_supported   ; get_idle      ; 02
06D6 83 89 [05]                         jmp             request_not_supported   ; get_protocol  ; 03
                
06D8                            ep0_in_jumptable:
06D8 83 89 [05]                         jmp             request_not_supported
06DA 83 96 [05]                         jmp             control_read_data_stage
06DC 83 C4 [05]                         jmp             control_write_status_stage
06DE 83 CF [05]                         jmp             no_data_control_status_stage            
                
06E0                            ep0_out_jumptable:
06E0 83 89 [05]                         jmp             request_not_supported
06E2 83 EA [05]                         jmp             control_read_status_stage
06E4 83 F5 [05]                         jmp             control_write_data_stage
06E6 84 33 [05]                         jmp             no_data_control_error
                
06E8                            get_device_descriptor_jumptable:
                
06E8 83 89 [05]                         jmp             request_not_supported
06EA 81 A3 [05]                         jmp             send_device_descriptor
06EC 81 AF [05]                         jmp             send_configuration_descriptor
06EE 81 BB [05]                         jmp             send_string_descriptor
06F0 81 E4 [05]                         jmp             send_interface_descriptor
06F2 81 F0 [05]                         jmp             send_endpoint_descriptor
                
06F4                            string_jumptable:
06F4 81 C0 [05]                         jmp             language_string
06F6 81 CC [05]                         jmp             manufacturer_string
06F8 81 D8 [05]                         jmp             product_string
                
0700            ORG             700h
                
0700            XPAGEON
0700                            out_report_type_jumptable:
0700 83 89 [05]                         jmp             request_not_supported ; valid values are 1,2,3
0702 83 89 [05]                         jmp             request_not_supported ; input report
0704 83 49 [05]                         jmp             get_output_report ; 2
0706 83 4F [05]                         jmp             get_feature_report ; 3
                
                
0708                            in_report_type_jumptable:
0708 83 89 [05]                         jmp             request_not_supported ; valid values are 1,2,3
070A 82 95 [05]                         jmp             send_input_report ; 1
070C 83 89 [05]                         jmp             request_not_supported  ;output report
070E 82 A5 [05]                         jmp             send_feature_report ; 3
                
                
0710            XPAGEON
                ;*********************************************************
                ;                   rom lookup tables
                ;*********************************************************
                
0710            XPAGEOFF
0800            ORG             800h
                
0800            control_read_table:
0800               device_desc_table:
0800 12    [00]         db      12h                     ; bLength (18 bytes)
0801 01    [00]         db      01h                     ; bDescriptorType (device descriptor)
0802 10    [00]         db      10h, 01h        ; bcdUSB (ver 1.1)
0803 01    [00] 
0804 00    [00]         db      00h                     ; bDeviceClass (each interface specifies class info)
0805 00    [00]         db      00h                     ; bDeviceSubClass (not specified)
0806 00    [00]         db      00h                     ; bDeviceProtocol (not specified)
0807 08    [00]         db      08h                     ; bMaxPacketSize0 (8 bytes)
0808 77    [00]         db      77h, 77h        ; idVendor (Lakeview Research: 7777h)
0809 77    [00] 
080A 34    [00]         db      34h, 12h        ; idProduct (1234h)
080B 12    [00] 
080C 00    [00]         db      00h, 01h        ; bcdDevice (1.00) 
080D 01    [00] 
080E 01    [00]         db      01h                     ; iManufacturer
080F 02    [00]         db      02h                     ; iProduct
0810 00    [00]         db      00h                     ; iSerialNumber (unused)
0811 01    [00]         db      01h                     ; bNumConfigurations (1)
                
0812               config_desc_table:
0812 09    [00]         db      09h                     ; bLength (9 bytes)
0813 02    [00]         db      02h                     ; bDescriptorType (CONFIGURATION)
0814 22    [00]         db      22h, 00h        ; wTotalLength (34 bytes)
0815 00    [00] 
0816 01    [00]         db      01h                     ; bNumInterfaces (1)
0817 01    [00]         db      01h                     ; bConfigurationValue (1)
0818 00    [00]         db      00h                     ; Configuration string (unused)
0819 80    [00]         db      80h                     ; bmAttributes (bus powered, remote wakeup)
081A 0D    [00]         db      0Dh                     ; MaxPower (13mA)
081B               interface_desc_table:
081B 09    [00]         db      09h                     ; bLength (9 bytes)
081C 04    [00]         db      04h                     ; bDescriptorType (INTERFACE)
081D 00    [00]         db      00h                     ; bInterfaceNumber (0)
081E 00    [00]         db      00h                     ; bAlternateSetting (0)
081F 01    [00]         db      01h                     ; bNumEndpoints (1)
0820 03    [00]         db      03h                     ; bInterfaceClass (3..defined by USB spec)
0821 00    [00]         db      00h                     ; bInterfaceSubClass (1..defined by USB spec)
0822 00    [00]         db      00h                     ; bInterfaceProtocol (2..defined by USB spec)
0823 00    [00]         db      00h                     ; iInterface (not supported)
0824               hid_desc_table:
                
0824 09    [00]         db      09h                     ; bLength (9 bytes)
0825 21    [00]         db      21h                     ; bDescriptorType (HID)
0826 00    [00]         db      00h, 01h        ; bcdHID (1.00) 
0827 01    [00] 
0828 00    [00]         db      00h                     ; bCountryCode (US)
0829 01    [00]         db      01h                     ; bNumDescriptors (1)
082A 22    [00]         db      22h                     ; bDescriptorType (HID)
082B 46    [00]         db      end_hid_report_desc_table - hid_report_desc_table, 00h  ; wDescriptorLength  
082C 00    [00] 
082D               endpoint_desc_table:
082D 07    [00]         db      07h                     ; bLength (7 bytes)
082E 05    [00]         db      05h                     ; bDescriptorType (ENDPOINT)
082F 81    [00]         db      81h                     ; bEndpointAddress (IN endpoint, endpoint 1)
0830 03    [00]         db      03h                     ; bmAttributes (interrupt)
0831 03    [00]         db      03h, 00h        ; wMaxPacketSize (3 bytes)
0832 00    [00] 
0833 0A    [00]         db      0Ah                     ; bInterval (10ms)
                
                
0834               hid_report_desc_table:
                
0834 06    [00]         db      06h, A0h, FFh   ; usage page (vendor defined)
0835 A0    [00] 
0836 FF    [00] 
0837 09    [00]         db      09h, 01h        ; usage (vendor defined)
0838 01    [00] 
0839 A1    [00]         db      A1h, 01h        ; collection (application)
083A 01    [00] 
083B 09    [00]         db      09h, 02h        ; usage (vendor defined)
083C 02    [00] 
083D A1    [00]         db      A1h, 00h        ; collection (linked)
083E 00    [00] 
083F 06    [00]         db      06h, A1h, FFh   ; usage page (vendor defined)
0840 A1    [00] 
0841 FF    [00] 
                
                ;The input report
0842 09    [00]      db 09h, 03h     ;               usage - vendor defined
0843 03    [00] 
0844 09    [00]      db 09h, 04h     ;               usage - vendor defined
0845 04    [00] 
0846 15    [00]      db 15h, 80h     ;               Logical Minimum (-128)
0847 80    [00] 
0848 25    [00]      db 25h, 7Fh     ;               Logical Maximum (127)
0849 7F    [00] 
                
084A 35    [00]      db 35h, 00h     ;               Physical Minimum (0)
084B 00    [00] 
084C 45    [00]      db 45h, FFh;                    Physical Maximum (255)
084D FF    [00] 
                ;    db 66h, 00h, 00h;               Unit (None (2 bytes))
084E 75    [00]      db 75h, 08h     ;               Report Size (8)  (bits)
084F 08    [00] 
0850 95    [00]      db 95h, 02h     ;               Report Count (2)  (fields)
0851 02    [00] 
0852 81    [00]      db 81h, 02h     ;               Input (Data, Variable, Absolute)  
0853 02    [00] 
                
                ;The output report
0854 09    [00]      db 09h, 05h     ;               usage - vendor defined
0855 05    [00] 
0856 09    [00]      db 09h, 06h     ;               usage - vendor defined
0857 06    [00] 
0858 15    [00]      db 15h, 80h     ;               Logical Minimum (-128)
0859 80    [00] 
085A 25    [00]      db 25h, 7Fh     ;               Logical Maximum (127)
085B 7F    [00] 
085C 35    [00]      db 35h, 00h     ;               Physical Minimum (0)
085D 00    [00] 
085E 45    [00]      db 45h, FFh     ;               Physical Maximum (255)
085F FF    [00] 
                ;    db 66h, 00h, 00h;               Unit (None (2 bytes))
0860 75    [00]      db 75h, 08h     ;               Report Size (8)  (bits)
0861 08    [00] 
0862 95    [00]      db 95h, 02h     ;               Report Count (2)  (fields)
0863 02    [00] 
0864 91    [00]      db 91h, 02h     ;               Output (Data, Variable, Absolute)  
0865 02    [00] 
                
                ;The Feature report
                ;     db 85h, 01h     ;               report ID
0866 09    [00]      db 09h, 05h     ;               usage - vendor defined
0867 05    [00] 
0868 09    [00]      db 09h, 06h     ;               usage - vendor defined
0869 06    [00] 
086A 15    [00]      db 15h, 80h     ;               Logical Minimum (-128)
086B 80    [00] 
086C 25    [00]      db 25h, 7Fh     ;               Logical Maximum (127)
086D 7F    [00] 
086E 35    [00]      db 35h, 00h     ;               Physical Minimum (0)
086F 00    [00] 
0870 45    [00]      db 45h, FFh     ;               Physical Maximum (255)
0871 FF    [00] 
                ;    db 66h, 00h, 00h;               Unit (None (2 bytes))
0872 75    [00]      db 75h, 08h     ;               Report Size (8)  (bits)
0873 08    [00] 
0874 95    [00]      db 95h, 02h     ;               Report Count (2)  (fields)
0875 02    [00] 
0876 B1    [00]      db B1h, 02h     ;               Feature (Data, Variable, Absolute)  
0877 02    [00] 
                
                
0878 C0    [00]         db      C0h, C0h        ; end collection, end collection
0879 C0    [00] 
                
087A                end_hid_report_desc_table:
                
087A               device_status_wakeup_disabled:
087A 00    [00]     db  00h, 00h    ; remote wakeup disabled, bus powered
087B 00    [00] 
                
087C               device_configured_table:
087C 01    [00]         db      01h                     ; device in configured state
087D               device_unconfigured_table:
087D 00    [00]         db      00h                     ; device in unconfigured state
                
                
087E               endpoint_nostall_table:
087E 00    [00]         db      00h, 00h        ; endpoint not stalled
087F 00    [00] 
0880               endpoint_stall_table:
0880 01    [00]         db      01h, 00h        ; endpoint stalled
0881 00    [00] 
                
0882               interface_status_table:
0882 00    [00]         db      00h, 00h        ; default response
0883 00    [00] 
                
                
0884               interface_alternate_table:
0884 00    [00]         db      00h                     ; only valid alternate setting
                
0885               interface_boot_protocol:
0885 00    [00]         db      00h
0886               interface_report_protocol:
0886 01    [00]         db      01h
                
0887               ilanguage_string:
0887 04    [00]     db 04h                                      ; Length
0888 03    [00]     db 03h                                      ; Type (3=string)
                
0889 09    [00]     db 09h                                      ; Language:  English
088A 04    [00]     db 04h                                      ; Sub-language: US
                
088B               imanufacturer_string:
                ;Length is (# of characters + 1) * 2
088B 38    [00]     db 38h                                      ; Length
088C 03    [00]     db 03h                                      ; Type (3=string)
088D 55 00 ...      dsu "USB HID Design by USBLab"
     53 00 42 00 20 00 48 00 49 00 44 00 20 00 44 00 65 00 73 00 69 00 67 00 6E 00 
     20 00 62 00 79 00 20 00 55 00 53 00 42 00 4C 00 61 00 62 00 
                
08BD               iproduct_string:
08BD 18    [00]     db 18h                                      ; Length
08BE 03    [00]     db 03h                                      ; Type (3=string)
08BF 48 00 ...      dsu "HID Example"
     49 00 44 00 20 00 45 00 78 00 61 00 6D 00 70 00 6C 00 65 00 
                
08D5            XPAGEOFF
                
                
                ;**********************************************************
                ;       APPLICATION SPECIFIC TABLES
                ;**********************************************************
08D5            XPAGEON
                
0900            ORG             900h
                
                
0900                            event_machine_jumptable:
0900 80 83 [05]                         jmp             no_event_pending
0902 80 B5 [05]                         jmp             no_event_task
                
0904            XPAGEON

CheckSum = DF2D
Warnings = 0
Errors   = 0

Product: 63743, CPU Family=B, RAM=256 bytes, ROM=8160 bytes

 *************** RAM USAGE MAP ***************

     |01234567|89ABCDEF|01234567|89ABCDEF|
 0-1F|        |        |        |        |
20-3F|        |        |        |        |
40-5F|        |        |        |        |
60-7F|        |        |        |        |
80-9F|        |        |        |        |
A0-BF|        |        |        |        |
C0-DF|        |        |        |        |
E0-FF|        |        |        |        |
     -------------------------------------
     RAM Used = 0(+)  RAM Available = 256   

 *************** ROM USAGE MAP ***************

         |01234567|89ABCDEF|01234567|89ABCDEF|
0000-01FF|FpFFFFFF|FFFFFFFF|FFFFFFFF|FFFFFFFF|
0200-03FF|FFFFFFFF|FFFFFFFF|FFFFFFFF|FFFFFFFF|
0400-05FF|FFFFFp  |        |        |        |
0600-07FF|FFFFFFFF|FFFFFFFp|F       |        |
0800-09FF|FFFFFFFF|FFFFFp  |p       |        |
0A00-0BFF|        |        |        |        |
0C00-0DFF|        |        |        |        |
0E00-0FFF|        |        |        |        |
1000-11FF|        |        |        |        |
1200-13FF|        |        |        |        |
1400-15FF|        |        |        |        |
1600-17FF|        |        |        |        |
1800-19FF|        |        |        |        |
1A00-1BFF|        |        |        |        |
1C00-1DFF|        |        |        |        |
1E00-1FFF|        |        |        |      XX|
         -------------------------------------
         ROM Used = 1600  ROM Available = 6560
         F = Full Block
         p = Partially Full Block
         X = Unpopulated Block

 ************ SYMBOLIC REFERENCE TABLE ************

 Value  Label                                # Uses
 -----  ------------------------------------ ------
    2H= 128US_INT                                 0
    4H= 1MS_INT                                   2
   CBH  1ms_suspend_timer                         0
   C8H  1ms_timer                                 1
    DH= ACK_IN                                    1
    FH= ACK_IN_STATUS_OUT                         1
    9H= ACK_OUT                                   0
    BH= ACK_OUT_NAK_IN                            1
    0H= ADDRESS_CHANGE_PENDING                    2
   80H= ADDRESS_ENABLE                            3
   7FH= ADDRESS_MASK                              0
    8H= BUS_ACTIVITY                              3
    FH= BYTE_COUNT                                0
    2H= CAPTUREA_FALL_EVENT                       0
    2H= CAPTUREA_FALL_INT                         0
   10H= CAPTUREA_INT                              0
    1H= CAPTUREA_RISE_EVENT                       0
    1H= CAPTUREA_RISE_INT                         0
    8H= CAPTUREB_FALL_EVENT                       0
    8H= CAPTUREB_FALL_INT                         0
   20H= CAPTUREB_INT                              0
    4H= CAPTUREB_RISE_EVENT                       0
    4H= CAPTUREB_RISE_INT                         0
   20H= CLASS_TYPE                                0
    0H= CLEAR                                     0
    1H= CLEAR_FEATURE                             0
    2H= CONFIGURATION                             0
    1H= CONTROL0                                  0
    2H= CONTROL1                                  0
    4H= CONTROL2                                  0
    2H= CONTROL_READ_DATA                         3
    4H= CPHA                                      0
    8H= CPOL                                      0
   80H= DATA_TOGGLE                               7
   40H= DATA_VALID                                1
    1H= DEVICE                                    0
   80H= DEVICETOHOST                              0
    1H= DEVICE_CONFIG_LENGTH                      1
    0H= DEVICE_RECIPIENT                          0
    1H= DEVICE_REMOTE_WAKEUP                      0
    2H= DEVICE_STATUS_LENGTH                      1
    0H= DISABLE                                   2
   10H= DMINUS                                    0
   20H= DPLUS                                     0
    5H= ENDPOINT                                  0
    2H= ENDPOINT_RECIPIENT                        0
    0H= ENDPOINT_STALL                            2
    2H= ENDPOINT_STALL_LENGTH                     1
   10H= EP0_ACK                                   1
   40H= EP0_IN                                    0
    1H= EP0_INT                                   3
    0H= EP0_IN_IDLE                               0
    6H= EP0_IN_STALL                              0
   20H= EP0_OUT                                   0
   80H= EP0_SETUP                                 0
    2H= EP1_INT                                   1
    4H= EP2_INT                                   0
   10H= EP_ACK                                    1
   80H= EP_STALL                                  0
    2H= EVENT_PENDING                             2
    1H= EXTERNAL_CLK                              1
   80H= EXT_DELAY                                 0
   80H= FIRST_EDGE_HOLD                           0
   40H= FORCEBOTH_LOW                             0
    6H= FORCESCLK_LOW                             0
    5H= FORCESDATA_LOW                            0
    7H= FORCE_HIZ                                 0
    2H= FORCE_J                                   0
    1H= FORCE_K                                   0
    3H= FORCE_SE0                                 0
    8H= GET_CONFIGURATION                         0
    6H= GET_DESCRIPTOR                            0
    2H= GET_IDLE                                  0
    AH= GET_INTERFACE                             0
    3H= GET_PROTOCOL                              0
    1H= GET_REPORT                                0
    0H= GET_STATUS                                0
   40H= GPIO_INT                                  0
    0H= HOSTTODEVICE                              0
    4H= IGNORE_IN_OUT                             0
    4H= INTERFACE                                 0
    1H= INTERFACE_ALTERNATE_LENGTH                1
    1H= INTERFACE_PROTOCOL_LENGTH                 1
    1H= INTERFACE_RECIPIENT                       0
    2H= INTERFACE_STATUS_LENGTH                   1
    2H= INTERNAL_CLK                              0
    4H= INT_ENABLE_SENSE                          0
   80H= IRQ_PENDING                               0
    7H= ISOCHRONOUS_IN                            0
    5H= ISOCHRONOUS_OUT                           0
    8H= LVR_ENABLE                                1
   10H= MODE0                                     0
   20H= MODE1                                     0
    FH= MODE_MASK                                 0
    CH= NAK_IN                                    1
    1H= NAK_IN_OUT                                5
    EH= NAK_IN_STATUS_OUT                         0
    8H= NAK_OUT                                   0
    AH= NAK_OUT_STATUS_IN                         0
    0H= NOT_FORCING                               0
    2H= NO_CHANGE_PENDING                         6
    4H= NO_DATA_STATUS                            0
    0H= NO_EVENT_PENDING                          1
    3H= OTHER_RECIPIENT                           0
   10H= POR_RESET                                 0
   70H= PRESCALE                                  0
   10H= PRESCALE0                                 0
   20H= PRESCALE1                                 0
   40H= PRESCALE2                                 0
   80H= PS2_PULLUP                                0
   60H= RESERVED_TYPE                             0
    1H= RUN                                       0
    1H= SCK_SELECT0                               0
    2H= SCK_SELECT1                               0
   20H= SCLK                                      0
   10H= SDATA                                     0
   FFH= SET                                       0
    5H= SET_ADDRESS                               0
    9H= SET_CONFIGURATION                         0
    7H= SET_DESCRIPTOR                            0
    3H= SET_FEATURE                               0
    AH= SET_IDLE                                  0
    BH= SET_INTERFACE                             0
    BH= SET_PROTOCOL                              0
    9H= SET_REPORT                                0
    8H= SPI_INT                                   0
    3H= STALL_IN_OUT                              6
    0H= STANDARD_TYPE                             0
    6H= STATUS_IN_ONLY                            3
    2H= STATUS_OUT_ONLY                           1
    3H= STRING                                    0
    8H= SUSPEND                                   1
    CH= SYNCH_FRAME                               0
   40H= TBF                                       0
   80H= TCMP                                      0
    2H= TRANS_CONTROL_READ                        2
    4H= TRANS_CONTROL_WRITE                       1
    0H= TRANS_NONE                                4
    6H= TRANS_NO_DATA_CONTROL                     1
   20H= USB_PS2_MODE                              0
   20H= USB_RESET                                 0
    1H= USB_RESET_INT                             3
   40H= VENDOR_TYPE                               0
    1H= VREG                                      0
   40H= VREG_ENABLE                               1
   10H= WAKEUP_ADJUST0                            0
   20H= WAKEUP_ADJUST1                            0
   40H= WAKEUP_ADJUST2                            0
   80H= WAKEUP_INT                                0
   40H= WDR                                       0
    2H= XTALIN                                    0
  21AH  alternate_not_supported                   0
  21CH  alternate_supported                       1
   F9H= bRequest                                  8
   F8H= bmRequestType                             1
  600H  bmRequestType_jumptable                   1
  2D9H  boot_protocol                             1
   F1H  bus_activity                              1
   B7H  bus_reset                                 1
   44H= capture_config                            0
   45H= capture_status                            0
   41H= capturea_falling                          0
   40H= capturea_rising                           0
   43H= captureb_falling                          0
   42H= captureb_rising                           0
  3D5H  change_address                            0
  304H  clear_endpoint_feature                    1
   ABH  clear_pending_events                      0
   F8H= clock_config                              1
  812H  config_desc_table                         2
   28H= configuration                             5
  16EH  configure_device                          1
   FFH= control                                   2
  396H  control_read_data_stage                   2
  3EAH  control_read_status_stage                 1
  800H  control_read_table                       19
  3F5H  control_write_data_stage                  1
  430H  control_write_data_stage_done             2
  3C4H  control_write_status_stage                1
  14DH  d2h_class_interface                       1
  6D0H  d2h_class_interface_jumptable             1
  13EH  d2h_std_device                            1
  68EH  d2h_std_device_jumptable                  1
  148H  d2h_std_endpoint                          1
  6B6H  d2h_std_endpoint_jumptable                1
  143H  d2h_std_interface                         1
  6A0H  d2h_std_interface_jumptable               1
   34H= data_byte_0                               0
   35H= data_byte_1                               0
   24H= data_count                                1
   23H= data_start                               20
  428H  data_toggle                               1
  208H  device_configured                         0
  87CH  device_configured_table                   1
  800H  device_desc_table                         2
  87AH  device_status_wakeup_disabled             1
  20EH  device_unconfigured                       1
  87DH  device_unconfigured_table                 1
  39EH  dmabuffer_load                            1
  3B2H  dmabuffer_load_done                       6
  87AH  end_hid_report_desc_table                 1
   FDH  endpoint0                                 1
  43EH  endpoint1                                 1
  459H  endpoint1_NAK                             2
  45DH  endpoint1_done                            1
  82DH  endpoint_desc_table                       2
   21H= endpoint_int                              3
  87EH  endpoint_nostall_table                    1
  32EH  endpoint_not_stalled                      0
  880H  endpoint_stall_table                      1
  334H  endpoint_stalled                          1
   11H= ep0_count                                 5
   22H= ep0_data_toggle                           8
   F8H= ep0_dmabuff                               8
   F8H= ep0_dmabuff0                              7
   F9H= ep0_dmabuff1                              5
   FAH= ep0_dmabuff2                              1
   FBH= ep0_dmabuff3                              1
   FCH= ep0_dmabuff4                              1
   FDH= ep0_dmabuff5                              1
   FEH= ep0_dmabuff6                              1
   FFH= ep0_dmabuff7                              1
  111H  ep0_done                                  1
   27H= ep0_in_flag                               8
  6D8H  ep0_in_jumptable                          1
   26H= ep0_in_machine                            4
  392H  ep0_in_received                           1
   12H= ep0_mode                                 16
  6E0H  ep0_out_jumptable                         1
  3E6H  ep0_out_received                          1
  114H  ep0_setup_received                        1
   33H= ep0_transtype                            11
   13H= ep1_count                                 1
   21H= ep1_data_toggle                           3
   F0H= ep1_dmabuff                              29
   F0H= ep1_dmabuff0                              4
   F1H= ep1_dmabuff1                              2
   F2H= ep1_dmabuff2                              2
   F3H= ep1_dmabuff3                              0
   F4H= ep1_dmabuff4                              0
   F5H= ep1_dmabuff5                              0
   F6H= ep1_dmabuff6                              0
   F7H= ep1_dmabuff7                              0
   14H= ep1_mode                                  9
  17CH  ep1_nak_in_out                            1
  180H  ep1_set_int                               1
   29H= ep1_stall                                 7
   15H= ep2_count                                 0
   16H= ep2_mode                                  0
   1AH  error                                     7
   2DH= event_machine                             5
  900H  event_machine_jumptable                   1
   B5H  event_pending                             0
   B5H  event_task_done                           0
  40AH  feature_report                            0
   38H= feature_report_byte_0                     2
   F1H= feature_report_byte_1                     2
   F2H= feature_report_byte_2                     0
   F3H= feature_report_byte_3                     0
   F4H= feature_report_byte_4                     0
   F5H= feature_report_byte_5                     0
   F6H= feature_report_byte_6                     0
   F7H= feature_report_byte_7                     0
  1FCH  get_device_configuration                  1
  19EH  get_device_descriptor                     1
  6E8H  get_device_descriptor_jumptable           1
  194H  get_device_status                         1
  324H  get_endpoint_status                       1
  34FH  get_feature_report                        1
  2DFH  get_interface_hid                         1
  2EBH  get_interface_hid_descriptor              1
  2F7H  get_interface_hid_report                  1
  2B5H  get_interface_idle                        0
  22CH  get_interface_interface                   1
  2C9H  get_interface_protocol                    0
  222H  get_interface_status                      1
  349H  get_output_report                         1
  284H  get_report                                1
   20H= global_int                                3
  139H  h2d_class_interface                       1
  674H  h2d_class_interface_jumptable             1
  12AH  h2d_std_device                            1
  640H  h2d_std_device_jumptable                  1
  134H  h2d_std_endpoint                          1
  66CH  h2d_std_endpoint_jumptable                1
  12FH  h2d_std_interface                         1
  654H  h2d_std_interface_jumptable               1
  824H  hid_desc_table                            3
  834H  hid_report_desc_table                     2
   2AH= idle                                      6
   31H= idle_prescaler                            4
   30H= idle_timer                                6
  24AH  idle_timer_disable                        1
  887H  ilanguage_string                          2
  88BH  imanufacturer_string                      2
  708H  in_report_type_jumptable                  1
  355H  initialize_control_read                  18
  36DH  initialize_control_read_done              2
  36FH  initialize_control_write                  2
  37EH  initialize_no_data_control                7
   40H= input_report_byte_0                       0
   F1H= input_report_byte_1                       0
   F2H= input_report_byte_2                       0
   F3H= input_report_byte_3                       0
   F4H= input_report_byte_4                       0
   F5H= input_report_byte_5                       0
   F6H= input_report_byte_6                       0
   F7H= input_report_byte_7                       0
   2FH= int_temp                                  3
  884H  interface_alternate_table                 1
  885H  interface_boot_protocol                   1
  81BH  interface_desc_table                      2
  886H  interface_report_protocol                 1
  882H  interface_status_table                    1
  8BDH  iproduct_string                           2
  1C0H  language_string                           1
   32H= logo_index                                1
  1CCH  manufacturer_string                       1
   25H= maximum_data_count                       19
   FBH  ms_timer_done                             1
  433H  no_data_control_error                     1
  3CFH  no_data_control_status_stage              1
  3DBH  no_data_status_done                       1
   83H  no_event_pending                          1
   B5H  no_event_task                             3
   B1H  no_input_report_to_send                   1
  700H  out_report_type_jumptable                 1
   37H= output_or_feature                         3
  414H  output_report                             1
   48H= output_report_byte_0                      2
   F1H= output_report_byte_1                      2
   F2H= output_report_byte_2                      0
   F3H= output_report_byte_3                      0
   F4H= output_report_byte_4                      0
   F5H= output_report_byte_5                      0
   F6H= output_report_byte_6                      0
   F7H= output_report_byte_7                      0
   36H= output_report_received                    3
   2EH= pending_data                              2
    0H= port0                                     3
   50H= port0_data_temp                           2
    4H= port0_int                                 0
    6H= port0_int_polarity                        0
    AH= port0_mode0                               2
    BH= port0_mode1                               2
    1H= port1                                     5
   51H= port1_data_temp                           1
    5H= port1_int                                 0
    7H= port1_int_polarity                        0
    CH= port1_mode0                               2
    DH= port1_mode1                               2
    2H= port2                                     0
  1D8H  product_string                            1
   2BH= protocol                                  3
  2D3H  report_protocol                           0
  389H  request_not_supported                    97
   1BH  reset                                     2
  1AFH  send_configuration_descriptor             1
  1A3H  send_device_descriptor                    1
  1F0H  send_endpoint_descriptor                  1
  2A5H  send_feature_report                       1
  295H  send_input_report                         1
  1E4H  send_interface_descriptor                 1
  1BBH  send_string_descriptor                    1
  152H  set_device_address                        1
  15CH  set_device_configuration                  1
  18EH  set_device_configuration_done             1
  314H  set_endpoint_feature                      1
  274H  set_idle_done                             3
  24EH  set_idle_last_not_expired                 1
  25EH  set_idle_new_timer_less                   1
  26AH  set_idle_normal                           1
  236H  set_interface_idle                        0
  214H  set_interface_interface                   1
  27AH  set_interface_protocol                    0
  33AH  set_report                                1
   61H= spi_control                               0
   60H= spi_data                                  0
  6F4H  string_jumptable                          1
   20H= suspend_count                             4
   69H  task_loop                                 2
   2CH= temp                                      0
   24H= timer_lsb                                 0
   25H= timer_msb                                 0
  162H  unconfigure_device                        0
   10H= usb_address                               3
   1FH= usb_status                                5
   DBH  usb_suspend                               2
   FDH= wIndexhi                                  0
   FCH= wIndexlo                                  0
   FFH= wLengthhi                                 2
   FEH= wLengthlo                                 3
   FBH= wValuehi                                  9
   FAH= wValuelo                                  7
   26H= watchdog                                  1
